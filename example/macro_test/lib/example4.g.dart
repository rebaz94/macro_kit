// GENERATED BY Macro: DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// dart format off

part of 'example4.dart';

mixin AddressData {
  static Address fromJson(Map<String, dynamic> json) {
    return Address(
      street: json['street'] as String,
      city: json['city'] as String,
      country: json['country'] as String,
      postalCode: json['postal_code'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final v = this as Address;
    return <String, dynamic>{
      'street': v.street,
      'city': v.city,
      'country': v.country,
      'postal_code': v.postalCode,
    };
  }

  Address copyWith({
    String? street,
    String? city,
    String? country,
    String? postalCode,
  }) {
    final v = this as Address;
    return Address(
      street: street ?? v.street,
      city: city ?? v.city,
      country: country ?? v.country,
      postalCode: postalCode ?? v.postalCode,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as Address;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Address &&
            (identical(other.street, v.street) || other.street == v.street) &&
            (identical(other.city, v.city) || other.city == v.city) &&
            (identical(other.country, v.country) || other.country == v.country) &&
            (identical(other.postalCode, v.postalCode) || other.postalCode == v.postalCode));
  }

  @override
  int get hashCode {
    final v = this as Address;
    return Object.hash(
      runtimeType,
      v.street,
      v.city,
      v.country,
      v.postalCode,
    );
  }

  @override
  String toString() {
    final v = this as Address;
    return 'Address{street: ${v.street}, city: ${v.city}, country: ${v.country}, postalCode: ${v.postalCode}}';
  }
}

mixin TagData {
  static Tag fromJson(Map<String, dynamic> json) {
    return Tag(
      id: (json['id'] as num).toInt(),
      label: json['label'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final v = this as Tag;
    return <String, dynamic>{
      'id': v.id,
      'label': v.label,
    };
  }

  Tag copyWith({
    int? id,
    String? label,
  }) {
    final v = this as Tag;
    return Tag(
      id: id ?? v.id,
      label: label ?? v.label,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as Tag;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Tag &&
            (identical(other.id, v.id) || other.id == v.id) &&
            (identical(other.label, v.label) || other.label == v.label));
  }

  @override
  int get hashCode {
    final v = this as Tag;
    return Object.hash(
      runtimeType,
      v.id,
      v.label,
    );
  }

  @override
  String toString() {
    final v = this as Tag;
    return 'Tag{id: ${v.id}, label: ${v.label}}';
  }
}

mixin UserProfileData {
  static UserProfile fromJson(Map<String, dynamic> json) {
    return UserProfile(
      id: json['id'] as String,
      username: json['username'] as String,
      email: json['email'] as String,
      age: (json['age'] as num).toInt(),
      isActive: json['is_active'] as bool,
      accountBalance: (json['account_balance'] as num).toDouble(),
      roles: (json['roles'] as List<dynamic>).map((e) => e as String).toList(),
      preferences: json['preferences'] as Map<String, dynamic>,
      profileImageUrl: json['profile_image_url'] == null ? null : Uri.parse(json['profile_image_url'] as String),
      createdAt: MacroExt.decodeDateTime(json['created_at']),
      lastLogin: MacroExt.decodeNullableDateTime(json['last_login']),
      address: json['address'] == null ? null : AddressData.fromJson(json['address'] as Map<String, dynamic>),
      tags: (json['tags'] as List<dynamic>).map((e) => TagData.fromJson(e as Map<String, dynamic>)).toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final v = this as UserProfile;
    return <String, dynamic>{
      'id': v.id,
      'username': v.username,
      'email': v.email,
      'age': v.age,
      'is_active': v.isActive,
      'account_balance': v.accountBalance,
      'roles': v.roles,
      'preferences': v.preferences,
      'profile_image_url': ?v.profileImageUrl?.toString(),
      'created_at': v.createdAt.toIso8601String(),
      'last_login': ?v.lastLogin?.toIso8601String(),
      'address': ?v.address?.toJson(),
      'tags': v.tags.map((e) => e.toJson()).toList(),
    };
  }

  UserProfile copyWith({
    String? id,
    String? username,
    String? email,
    int? age,
    bool? isActive,
    double? accountBalance,
    List<String>? roles,
    Map<String, dynamic>? preferences,
    Uri? profileImageUrl,
    DateTime? createdAt,
    DateTime? lastLogin,
    Address? address,
    List<Tag>? tags,
  }) {
    final v = this as UserProfile;
    return UserProfile(
      id: id ?? v.id,
      username: username ?? v.username,
      email: email ?? v.email,
      age: age ?? v.age,
      isActive: isActive ?? v.isActive,
      accountBalance: accountBalance ?? v.accountBalance,
      roles: roles ?? v.roles,
      preferences: preferences ?? v.preferences,
      profileImageUrl: profileImageUrl ?? v.profileImageUrl,
      createdAt: createdAt ?? v.createdAt,
      lastLogin: lastLogin ?? v.lastLogin,
      address: address ?? v.address,
      tags: tags ?? v.tags,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as UserProfile;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is UserProfile &&
            (identical(other.id, v.id) || other.id == v.id) &&
            (identical(other.username, v.username) || other.username == v.username) &&
            (identical(other.email, v.email) || other.email == v.email) &&
            (identical(other.age, v.age) || other.age == v.age) &&
            (identical(other.isActive, v.isActive) || other.isActive == v.isActive) &&
            (identical(other.accountBalance, v.accountBalance) || other.accountBalance == v.accountBalance) &&
            const DeepCollectionEquality().equals(other.roles, v.roles) &&
            const DeepCollectionEquality().equals(other.preferences, v.preferences) &&
            (identical(other.profileImageUrl, v.profileImageUrl) || other.profileImageUrl == v.profileImageUrl) &&
            (identical(other.createdAt, v.createdAt) || other.createdAt == v.createdAt) &&
            (identical(other.lastLogin, v.lastLogin) || other.lastLogin == v.lastLogin) &&
            (identical(other.address, v.address) || other.address == v.address) &&
            const DeepCollectionEquality().equals(other.tags, v.tags));
  }

  @override
  int get hashCode {
    final v = this as UserProfile;
    return Object.hash(
      runtimeType,
      v.id,
      v.username,
      v.email,
      v.age,
      v.isActive,
      v.accountBalance,
      const DeepCollectionEquality().hash(v.roles),
      const DeepCollectionEquality().hash(v.preferences),
      v.profileImageUrl,
      v.createdAt,
      v.lastLogin,
      v.address,
      const DeepCollectionEquality().hash(v.tags),
    );
  }

  @override
  String toString() {
    final v = this as UserProfile;
    return 'UserProfile{id: ${v.id}, username: ${v.username}, email: ${v.email}, age: ${v.age}, isActive: ${v.isActive}, accountBalance: ${v.accountBalance}, roles: ${v.roles}, preferences: ${v.preferences}, profileImageUrl: ${v.profileImageUrl}, createdAt: ${v.createdAt}, lastLogin: ${v.lastLogin}, address: ${v.address}, tags: ${v.tags}}';
  }
}

mixin ApiResponseData<T> {
  static ApiResponse<T> fromJson<T>(Map<String, dynamic> json, T Function(Object? v) fromJsonT) {
    return ApiResponse<T>(
      status: json['status'] as String,
      code: (json['code'] as num).toInt(),
      timestamp: MacroExt.decodeDateTime(json['timestamp']),
      message: json['message'] as String?,
      data: MacroExt.decodeNullableGeneric(json['data'], fromJsonT),
    );
  }

  Map<String, dynamic> toJson(Object? Function(T v) toJsonT) {
    final v = this as ApiResponse<T>;
    return <String, dynamic>{
      'status': v.status,
      'code': v.code,
      'timestamp': v.timestamp.toIso8601String(),
      'message': ?v.message,
      'data': ?MacroExt.encodeNullableGeneric(v.data, toJsonT),
    };
  }

  ApiResponse<T> copyWith({
    String? status,
    int? code,
    DateTime? timestamp,
    String? message,
    T? data,
  }) {
    final v = this as ApiResponse<T>;
    return ApiResponse<T>(
      status: status ?? v.status,
      code: code ?? v.code,
      timestamp: timestamp ?? v.timestamp,
      message: message ?? v.message,
      data: data ?? v.data,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as ApiResponse<T>;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiResponse<T> &&
            (identical(other.status, v.status) || other.status == v.status) &&
            (identical(other.code, v.code) || other.code == v.code) &&
            (identical(other.timestamp, v.timestamp) || other.timestamp == v.timestamp) &&
            (identical(other.message, v.message) || other.message == v.message) &&
            (identical(other.data, v.data) || other.data == v.data));
  }

  @override
  int get hashCode {
    final v = this as ApiResponse<T>;
    return Object.hash(
      runtimeType,
      v.status,
      v.code,
      v.timestamp,
      v.message,
      v.data,
    );
  }

  @override
  String toString() {
    final v = this as ApiResponse<T>;
    return 'ApiResponse<$T>{status: ${v.status}, code: ${v.code}, timestamp: ${v.timestamp}, message: ${v.message}, data: ${v.data}}';
  }
}

mixin PaginatedData<T> {
  static Paginated<T> fromJson<T>(Map<String, dynamic> json, T Function(Object? v) fromJsonT) {
    return Paginated<T>(
      items: (json['items'] as List<dynamic>).map((e) => fromJsonT(e)).toList(),
      totalCount: (json['total_count'] as num).toInt(),
      page: (json['page'] as num).toInt(),
      pageSize: (json['page_size'] as num).toInt(),
    );
  }

  Map<String, dynamic> toJson(Object? Function(T v) toJsonT) {
    final v = this as Paginated<T>;
    return <String, dynamic>{
      'items': v.items.map((e) => toJsonT(e)).toList(),
      'total_count': v.totalCount,
      'page': v.page,
      'page_size': v.pageSize,
    };
  }

  Paginated<T> copyWith({
    List<T>? items,
    int? totalCount,
    int? page,
    int? pageSize,
  }) {
    final v = this as Paginated<T>;
    return Paginated<T>(
      items: items ?? v.items,
      totalCount: totalCount ?? v.totalCount,
      page: page ?? v.page,
      pageSize: pageSize ?? v.pageSize,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as Paginated<T>;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Paginated<T> &&
            const DeepCollectionEquality().equals(other.items, v.items) &&
            (identical(other.totalCount, v.totalCount) || other.totalCount == v.totalCount) &&
            (identical(other.page, v.page) || other.page == v.page) &&
            (identical(other.pageSize, v.pageSize) || other.pageSize == v.pageSize));
  }

  @override
  int get hashCode {
    final v = this as Paginated<T>;
    return Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(v.items),
      v.totalCount,
      v.page,
      v.pageSize,
    );
  }

  @override
  String toString() {
    final v = this as Paginated<T>;
    return 'Paginated<$T>{items: ${v.items}, totalCount: ${v.totalCount}, page: ${v.page}, pageSize: ${v.pageSize}}';
  }
}

mixin ProductAttributeData {
  static ProductAttribute fromJson(Map<String, dynamic> json) {
    return ProductAttribute(
      label: json['label'] as String,
      value: json['value'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final v = this as ProductAttribute;
    return <String, dynamic>{
      'label': v.label,
      'value': v.value,
    };
  }

  ProductAttribute copyWith({
    String? label,
    String? value,
  }) {
    final v = this as ProductAttribute;
    return ProductAttribute(
      label: label ?? v.label,
      value: value ?? v.value,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as ProductAttribute;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ProductAttribute &&
            (identical(other.label, v.label) || other.label == v.label) &&
            (identical(other.value, v.value) || other.value == v.value));
  }

  @override
  int get hashCode {
    final v = this as ProductAttribute;
    return Object.hash(
      runtimeType,
      v.label,
      v.value,
    );
  }

  @override
  String toString() {
    final v = this as ProductAttribute;
    return 'ProductAttribute{label: ${v.label}, value: ${v.value}}';
  }
}

mixin ProductData {
  static Product fromJson(Map<String, dynamic> json) {
    return Product(
      id: json['id'] as String,
      title: json['title'] as String,
      price: (json['price'] as num).toDouble(),
      metadata: json['metadata'] as Map<String, dynamic>,
      tags: (json['tags'] as List<dynamic>).map((e) => e as String).toList(),
      attributes: (json['attributes'] as Map<String, dynamic>).map(
        (k, e) => MapEntry(k, ProductAttributeData.fromJson(e as Map<String, dynamic>)),
      ),
    );
  }

  Map<String, dynamic> toJson() {
    final v = this as Product;
    return <String, dynamic>{
      'id': v.id,
      'title': v.title,
      'price': v.price,
      'metadata': v.metadata,
      'tags': v.tags,
      'attributes': v.attributes.map((k, e) => MapEntry(k, e.toJson())),
    };
  }

  Product copyWith({
    String? id,
    String? title,
    double? price,
    Map<String, dynamic>? metadata,
    List<String>? tags,
    Map<String, ProductAttribute>? attributes,
  }) {
    final v = this as Product;
    return Product(
      id: id ?? v.id,
      title: title ?? v.title,
      price: price ?? v.price,
      metadata: metadata ?? v.metadata,
      tags: tags ?? v.tags,
      attributes: attributes ?? v.attributes,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as Product;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Product &&
            (identical(other.id, v.id) || other.id == v.id) &&
            (identical(other.title, v.title) || other.title == v.title) &&
            (identical(other.price, v.price) || other.price == v.price) &&
            const DeepCollectionEquality().equals(other.metadata, v.metadata) &&
            const DeepCollectionEquality().equals(other.tags, v.tags) &&
            const DeepCollectionEquality().equals(other.attributes, v.attributes));
  }

  @override
  int get hashCode {
    final v = this as Product;
    return Object.hash(
      runtimeType,
      v.id,
      v.title,
      v.price,
      const DeepCollectionEquality().hash(v.metadata),
      const DeepCollectionEquality().hash(v.tags),
      const DeepCollectionEquality().hash(v.attributes),
    );
  }

  @override
  String toString() {
    final v = this as Product;
    return 'Product{id: ${v.id}, title: ${v.title}, price: ${v.price}, metadata: ${v.metadata}, tags: ${v.tags}, attributes: ${v.attributes}}';
  }
}

mixin SimpleUserData {
  static SimpleUser fromJson(Map<String, dynamic> json) {
    return SimpleUser(
      login: json['login'] as String,
      id: (json['id'] as num).toInt(),
      avatarUrl: json['avatar_url'] as String,
      type: json['type'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final v = this as SimpleUser;
    return <String, dynamic>{
      'login': v.login,
      'id': v.id,
      'avatar_url': v.avatarUrl,
      'type': v.type,
    };
  }

  SimpleUser copyWith({
    String? login,
    int? id,
    String? avatarUrl,
    String? type,
  }) {
    final v = this as SimpleUser;
    return SimpleUser(
      login: login ?? v.login,
      id: id ?? v.id,
      avatarUrl: avatarUrl ?? v.avatarUrl,
      type: type ?? v.type,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as SimpleUser;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is SimpleUser &&
            (identical(other.login, v.login) || other.login == v.login) &&
            (identical(other.id, v.id) || other.id == v.id) &&
            (identical(other.avatarUrl, v.avatarUrl) || other.avatarUrl == v.avatarUrl) &&
            (identical(other.type, v.type) || other.type == v.type));
  }

  @override
  int get hashCode {
    final v = this as SimpleUser;
    return Object.hash(
      runtimeType,
      v.login,
      v.id,
      v.avatarUrl,
      v.type,
    );
  }

  @override
  String toString() {
    final v = this as SimpleUser;
    return 'SimpleUser{login: ${v.login}, id: ${v.id}, avatarUrl: ${v.avatarUrl}, type: ${v.type}}';
  }
}

mixin LicenseData {
  static License fromJson(Map<String, dynamic> json) {
    return License(
      key: json['key'] as String,
      name: json['name'] as String,
      spdxId: json['spdx_id'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final v = this as License;
    return <String, dynamic>{
      'key': v.key,
      'name': v.name,
      'spdx_id': ?v.spdxId,
    };
  }

  License copyWith({
    String? key,
    String? name,
    String? spdxId,
  }) {
    final v = this as License;
    return License(
      key: key ?? v.key,
      name: name ?? v.name,
      spdxId: spdxId ?? v.spdxId,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as License;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is License &&
            (identical(other.key, v.key) || other.key == v.key) &&
            (identical(other.name, v.name) || other.name == v.name) &&
            (identical(other.spdxId, v.spdxId) || other.spdxId == v.spdxId));
  }

  @override
  int get hashCode {
    final v = this as License;
    return Object.hash(
      runtimeType,
      v.key,
      v.name,
      v.spdxId,
    );
  }

  @override
  String toString() {
    final v = this as License;
    return 'License{key: ${v.key}, name: ${v.name}, spdxId: ${v.spdxId}}';
  }
}

mixin PermissionsData {
  static Permissions fromJson(Map<String, dynamic> json) {
    return Permissions(
      admin: json['admin'] as bool,
      push: json['push'] as bool,
      pull: json['pull'] as bool,
    );
  }

  Map<String, dynamic> toJson() {
    final v = this as Permissions;
    return <String, dynamic>{
      'admin': v.admin,
      'push': v.push,
      'pull': v.pull,
    };
  }

  Permissions copyWith({
    bool? admin,
    bool? push,
    bool? pull,
  }) {
    final v = this as Permissions;
    return Permissions(
      admin: admin ?? v.admin,
      push: push ?? v.push,
      pull: pull ?? v.pull,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as Permissions;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Permissions &&
            (identical(other.admin, v.admin) || other.admin == v.admin) &&
            (identical(other.push, v.push) || other.push == v.push) &&
            (identical(other.pull, v.pull) || other.pull == v.pull));
  }

  @override
  int get hashCode {
    final v = this as Permissions;
    return Object.hash(
      runtimeType,
      v.admin,
      v.push,
      v.pull,
    );
  }

  @override
  String toString() {
    final v = this as Permissions;
    return 'Permissions{admin: ${v.admin}, push: ${v.push}, pull: ${v.pull}}';
  }
}

mixin RepositoryData {
  static Repository fromJson(Map<String, dynamic> json) {
    return Repository(
      id: (json['id'] as num).toInt(),
      nodeId: json['node_id'] as String,
      name: json['name'] as String,
      fullName: json['full_name'] as String,
      owner: SimpleUserData.fromJson(json['owner'] as Map<String, dynamic>),
      isPrivate: json['private'] as bool,
      htmlUrl: json['html_url'] as String,
      description: json['description'] as String?,
      fork: json['fork'] as bool,
      url: json['url'] as String,
      createdAt: MacroExt.decodeDateTime(json['created_at']),
      updatedAt: MacroExt.decodeDateTime(json['updated_at']),
      pushedAt: MacroExt.decodeNullableDateTime(json['pushed_at']),
      stargazersCount: (json['stargazers_count'] as num).toInt(),
      watchersCount: (json['watchers_count'] as num).toInt(),
      language: json['language'] as String?,
      forksCount: (json['forks_count'] as num).toInt(),
      openIssuesCount: (json['open_issues_count'] as num).toInt(),
      license: json['license'] == null ? null : LicenseData.fromJson(json['license'] as Map<String, dynamic>),
      permissions: json['permissions'] == null
          ? null
          : PermissionsData.fromJson(json['permissions'] as Map<String, dynamic>),
      visibility: MacroExt.decodeEnum(Visibility.values, json['visibility'], unknownValue: null),
    );
  }

  Map<String, dynamic> toJson() {
    final v = this as Repository;
    return <String, dynamic>{
      'id': v.id,
      'node_id': v.nodeId,
      'name': v.name,
      'full_name': v.fullName,
      'owner': v.owner.toJson(),
      'private': v.isPrivate,
      'html_url': v.htmlUrl,
      'description': ?v.description,
      'fork': v.fork,
      'url': v.url,
      'created_at': v.createdAt.toIso8601String(),
      'updated_at': v.updatedAt.toIso8601String(),
      'pushed_at': ?v.pushedAt?.toIso8601String(),
      'stargazers_count': v.stargazersCount,
      'watchers_count': v.watchersCount,
      'language': ?v.language,
      'forks_count': v.forksCount,
      'open_issues_count': v.openIssuesCount,
      'license': ?v.license?.toJson(),
      'permissions': ?v.permissions?.toJson(),
      'visibility': v.visibility.name,
    };
  }

  Repository copyWith({
    int? id,
    String? nodeId,
    String? name,
    String? fullName,
    SimpleUser? owner,
    bool? isPrivate,
    String? htmlUrl,
    String? description,
    bool? fork,
    String? url,
    DateTime? createdAt,
    DateTime? updatedAt,
    DateTime? pushedAt,
    int? stargazersCount,
    int? watchersCount,
    String? language,
    int? forksCount,
    int? openIssuesCount,
    License? license,
    Permissions? permissions,
    Visibility? visibility,
  }) {
    final v = this as Repository;
    return Repository(
      id: id ?? v.id,
      nodeId: nodeId ?? v.nodeId,
      name: name ?? v.name,
      fullName: fullName ?? v.fullName,
      owner: owner ?? v.owner,
      isPrivate: isPrivate ?? v.isPrivate,
      htmlUrl: htmlUrl ?? v.htmlUrl,
      description: description ?? v.description,
      fork: fork ?? v.fork,
      url: url ?? v.url,
      createdAt: createdAt ?? v.createdAt,
      updatedAt: updatedAt ?? v.updatedAt,
      pushedAt: pushedAt ?? v.pushedAt,
      stargazersCount: stargazersCount ?? v.stargazersCount,
      watchersCount: watchersCount ?? v.watchersCount,
      language: language ?? v.language,
      forksCount: forksCount ?? v.forksCount,
      openIssuesCount: openIssuesCount ?? v.openIssuesCount,
      license: license ?? v.license,
      permissions: permissions ?? v.permissions,
      visibility: visibility ?? v.visibility,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as Repository;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Repository &&
            (identical(other.id, v.id) || other.id == v.id) &&
            (identical(other.nodeId, v.nodeId) || other.nodeId == v.nodeId) &&
            (identical(other.name, v.name) || other.name == v.name) &&
            (identical(other.fullName, v.fullName) || other.fullName == v.fullName) &&
            (identical(other.owner, v.owner) || other.owner == v.owner) &&
            (identical(other.isPrivate, v.isPrivate) || other.isPrivate == v.isPrivate) &&
            (identical(other.htmlUrl, v.htmlUrl) || other.htmlUrl == v.htmlUrl) &&
            (identical(other.description, v.description) || other.description == v.description) &&
            (identical(other.fork, v.fork) || other.fork == v.fork) &&
            (identical(other.url, v.url) || other.url == v.url) &&
            (identical(other.createdAt, v.createdAt) || other.createdAt == v.createdAt) &&
            (identical(other.updatedAt, v.updatedAt) || other.updatedAt == v.updatedAt) &&
            (identical(other.pushedAt, v.pushedAt) || other.pushedAt == v.pushedAt) &&
            (identical(other.stargazersCount, v.stargazersCount) || other.stargazersCount == v.stargazersCount) &&
            (identical(other.watchersCount, v.watchersCount) || other.watchersCount == v.watchersCount) &&
            (identical(other.language, v.language) || other.language == v.language) &&
            (identical(other.forksCount, v.forksCount) || other.forksCount == v.forksCount) &&
            (identical(other.openIssuesCount, v.openIssuesCount) || other.openIssuesCount == v.openIssuesCount) &&
            (identical(other.license, v.license) || other.license == v.license) &&
            (identical(other.permissions, v.permissions) || other.permissions == v.permissions) &&
            (identical(other.visibility, v.visibility) || other.visibility == v.visibility));
  }

  @override
  int get hashCode {
    final v = this as Repository;
    return Object.hashAll([
      runtimeType,
      v.id,
      v.nodeId,
      v.name,
      v.fullName,
      v.owner,
      v.isPrivate,
      v.htmlUrl,
      v.description,
      v.fork,
      v.url,
      v.createdAt,
      v.updatedAt,
      v.pushedAt,
      v.stargazersCount,
      v.watchersCount,
      v.language,
      v.forksCount,
      v.openIssuesCount,
      v.license,
      v.permissions,
      v.visibility,
    ]);
  }

  @override
  String toString() {
    final v = this as Repository;
    return 'Repository{id: ${v.id}, nodeId: ${v.nodeId}, name: ${v.name}, fullName: ${v.fullName}, owner: ${v.owner}, isPrivate: ${v.isPrivate}, htmlUrl: ${v.htmlUrl}, description: ${v.description}, fork: ${v.fork}, url: ${v.url}, createdAt: ${v.createdAt}, updatedAt: ${v.updatedAt}, pushedAt: ${v.pushedAt}, stargazersCount: ${v.stargazersCount}, watchersCount: ${v.watchersCount}, language: ${v.language}, forksCount: ${v.forksCount}, openIssuesCount: ${v.openIssuesCount}, license: ${v.license}, permissions: ${v.permissions}, visibility: ${v.visibility}}';
  }
}

mixin LabelData {
  static Label fromJson(Map<String, dynamic> json) {
    return Label(
      id: (json['id'] as num).toInt(),
      name: json['name'] as String,
      color: json['color'] as String,
      description: json['description'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final v = this as Label;
    return <String, dynamic>{
      'id': v.id,
      'name': v.name,
      'color': v.color,
      'description': ?v.description,
    };
  }

  Label copyWith({
    int? id,
    String? name,
    String? color,
    String? description,
  }) {
    final v = this as Label;
    return Label(
      id: id ?? v.id,
      name: name ?? v.name,
      color: color ?? v.color,
      description: description ?? v.description,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as Label;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Label &&
            (identical(other.id, v.id) || other.id == v.id) &&
            (identical(other.name, v.name) || other.name == v.name) &&
            (identical(other.color, v.color) || other.color == v.color) &&
            (identical(other.description, v.description) || other.description == v.description));
  }

  @override
  int get hashCode {
    final v = this as Label;
    return Object.hash(
      runtimeType,
      v.id,
      v.name,
      v.color,
      v.description,
    );
  }

  @override
  String toString() {
    final v = this as Label;
    return 'Label{id: ${v.id}, name: ${v.name}, color: ${v.color}, description: ${v.description}}';
  }
}

mixin CommentData {
  static Comment fromJson(Map<String, dynamic> json) {
    return Comment(
      id: (json['id'] as num).toInt(),
      user: SimpleUserData.fromJson(json['user'] as Map<String, dynamic>),
      body: json['body'] as String,
      createdAt: MacroExt.decodeDateTime(json['created_at']),
      updatedAt: MacroExt.decodeNullableDateTime(json['updated_at']),
    );
  }

  Map<String, dynamic> toJson() {
    final v = this as Comment;
    return <String, dynamic>{
      'id': v.id,
      'user': v.user.toJson(),
      'body': v.body,
      'created_at': v.createdAt.toIso8601String(),
      'updated_at': ?v.updatedAt?.toIso8601String(),
    };
  }

  Comment copyWith({
    int? id,
    SimpleUser? user,
    String? body,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    final v = this as Comment;
    return Comment(
      id: id ?? v.id,
      user: user ?? v.user,
      body: body ?? v.body,
      createdAt: createdAt ?? v.createdAt,
      updatedAt: updatedAt ?? v.updatedAt,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as Comment;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Comment &&
            (identical(other.id, v.id) || other.id == v.id) &&
            (identical(other.user, v.user) || other.user == v.user) &&
            (identical(other.body, v.body) || other.body == v.body) &&
            (identical(other.createdAt, v.createdAt) || other.createdAt == v.createdAt) &&
            (identical(other.updatedAt, v.updatedAt) || other.updatedAt == v.updatedAt));
  }

  @override
  int get hashCode {
    final v = this as Comment;
    return Object.hash(
      runtimeType,
      v.id,
      v.user,
      v.body,
      v.createdAt,
      v.updatedAt,
    );
  }

  @override
  String toString() {
    final v = this as Comment;
    return 'Comment{id: ${v.id}, user: ${v.user}, body: ${v.body}, createdAt: ${v.createdAt}, updatedAt: ${v.updatedAt}}';
  }
}

mixin IssueData {
  static Issue fromJson(Map<String, dynamic> json) {
    return Issue(
      id: (json['id'] as num).toInt(),
      number: (json['number'] as num).toInt(),
      title: json['title'] as String,
      user: SimpleUserData.fromJson(json['user'] as Map<String, dynamic>),
      state: MacroExt.decodeEnum(IssueState.values, json['state'], unknownValue: null),
      labels: (json['labels'] as List<dynamic>).map((e) => LabelData.fromJson(e as Map<String, dynamic>)).toList(),
      assignees: (json['assignees'] as List<dynamic>)
          .map((e) => SimpleUserData.fromJson(e as Map<String, dynamic>))
          .toList(),
      commentsCount: (json['comments'] as num).toInt(),
      createdAt: MacroExt.decodeDateTime(json['created_at']),
      updatedAt: MacroExt.decodeNullableDateTime(json['updated_at']),
      closedAt: MacroExt.decodeNullableDateTime(json['closed_at']),
      body: json['body'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final v = this as Issue;
    return <String, dynamic>{
      'id': v.id,
      'number': v.number,
      'title': v.title,
      'user': v.user.toJson(),
      'state': v.state.name,
      'labels': v.labels.map((e) => e.toJson()).toList(),
      'assignees': v.assignees.map((e) => e.toJson()).toList(),
      'comments': v.commentsCount,
      'created_at': v.createdAt.toIso8601String(),
      'updated_at': ?v.updatedAt?.toIso8601String(),
      'closed_at': ?v.closedAt?.toIso8601String(),
      'body': ?v.body,
    };
  }

  Issue copyWith({
    int? id,
    int? number,
    String? title,
    SimpleUser? user,
    IssueState? state,
    List<Label>? labels,
    List<SimpleUser>? assignees,
    int? commentsCount,
    DateTime? createdAt,
    DateTime? updatedAt,
    DateTime? closedAt,
    String? body,
  }) {
    final v = this as Issue;
    return Issue(
      id: id ?? v.id,
      number: number ?? v.number,
      title: title ?? v.title,
      user: user ?? v.user,
      state: state ?? v.state,
      labels: labels ?? v.labels,
      assignees: assignees ?? v.assignees,
      commentsCount: commentsCount ?? v.commentsCount,
      createdAt: createdAt ?? v.createdAt,
      updatedAt: updatedAt ?? v.updatedAt,
      closedAt: closedAt ?? v.closedAt,
      body: body ?? v.body,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as Issue;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Issue &&
            (identical(other.id, v.id) || other.id == v.id) &&
            (identical(other.number, v.number) || other.number == v.number) &&
            (identical(other.title, v.title) || other.title == v.title) &&
            (identical(other.user, v.user) || other.user == v.user) &&
            (identical(other.state, v.state) || other.state == v.state) &&
            const DeepCollectionEquality().equals(other.labels, v.labels) &&
            const DeepCollectionEquality().equals(other.assignees, v.assignees) &&
            (identical(other.commentsCount, v.commentsCount) || other.commentsCount == v.commentsCount) &&
            (identical(other.createdAt, v.createdAt) || other.createdAt == v.createdAt) &&
            (identical(other.updatedAt, v.updatedAt) || other.updatedAt == v.updatedAt) &&
            (identical(other.closedAt, v.closedAt) || other.closedAt == v.closedAt) &&
            (identical(other.body, v.body) || other.body == v.body));
  }

  @override
  int get hashCode {
    final v = this as Issue;
    return Object.hash(
      runtimeType,
      v.id,
      v.number,
      v.title,
      v.user,
      v.state,
      const DeepCollectionEquality().hash(v.labels),
      const DeepCollectionEquality().hash(v.assignees),
      v.commentsCount,
      v.createdAt,
      v.updatedAt,
      v.closedAt,
      v.body,
    );
  }

  @override
  String toString() {
    final v = this as Issue;
    return 'Issue{id: ${v.id}, number: ${v.number}, title: ${v.title}, user: ${v.user}, state: ${v.state}, labels: ${v.labels}, assignees: ${v.assignees}, commentsCount: ${v.commentsCount}, createdAt: ${v.createdAt}, updatedAt: ${v.updatedAt}, closedAt: ${v.closedAt}, body: ${v.body}}';
  }
}

mixin BranchRefData {
  static BranchRef fromJson(Map<String, dynamic> json) {
    return BranchRef(
      label: json['label'] as String,
      ref: json['ref'] as String,
      sha: json['sha'] as String,
      user: SimpleUserData.fromJson(json['user'] as Map<String, dynamic>),
      repo: RepositoryData.fromJson(json['repo'] as Map<String, dynamic>),
    );
  }

  Map<String, dynamic> toJson() {
    final v = this as BranchRef;
    return <String, dynamic>{
      'label': v.label,
      'ref': v.ref,
      'sha': v.sha,
      'user': v.user.toJson(),
      'repo': v.repo.toJson(),
    };
  }

  BranchRef copyWith({
    String? label,
    String? ref,
    String? sha,
    SimpleUser? user,
    Repository? repo,
  }) {
    final v = this as BranchRef;
    return BranchRef(
      label: label ?? v.label,
      ref: ref ?? v.ref,
      sha: sha ?? v.sha,
      user: user ?? v.user,
      repo: repo ?? v.repo,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as BranchRef;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is BranchRef &&
            (identical(other.label, v.label) || other.label == v.label) &&
            (identical(other.ref, v.ref) || other.ref == v.ref) &&
            (identical(other.sha, v.sha) || other.sha == v.sha) &&
            (identical(other.user, v.user) || other.user == v.user) &&
            (identical(other.repo, v.repo) || other.repo == v.repo));
  }

  @override
  int get hashCode {
    final v = this as BranchRef;
    return Object.hash(
      runtimeType,
      v.label,
      v.ref,
      v.sha,
      v.user,
      v.repo,
    );
  }

  @override
  String toString() {
    final v = this as BranchRef;
    return 'BranchRef{label: ${v.label}, ref: ${v.ref}, sha: ${v.sha}, user: ${v.user}, repo: ${v.repo}}';
  }
}

mixin PullRequestData {
  static PullRequest fromJson(Map<String, dynamic> json) {
    return PullRequest(
      id: (json['id'] as num).toInt(),
      number: (json['number'] as num).toInt(),
      title: json['title'] as String,
      user: SimpleUserData.fromJson(json['user'] as Map<String, dynamic>),
      body: json['body'] as String?,
      state: MacroExt.decodeEnum(IssueState.values, json['state'], unknownValue: null),
      merged: json['merged'] as bool,
      mergeState: MacroExt.decodeEnum(MergeState.values, json['mergeable_state'], unknownValue: null),
      createdAt: MacroExt.decodeDateTime(json['created_at']),
      updatedAt: MacroExt.decodeNullableDateTime(json['updated_at']),
      closedAt: MacroExt.decodeNullableDateTime(json['closed_at']),
      mergedAt: MacroExt.decodeNullableDateTime(json['merged_at']),
      head: BranchRefData.fromJson(json['head'] as Map<String, dynamic>),
      base: BranchRefData.fromJson(json['base'] as Map<String, dynamic>),
    );
  }

  Map<String, dynamic> toJson() {
    final v = this as PullRequest;
    return <String, dynamic>{
      'id': v.id,
      'number': v.number,
      'title': v.title,
      'user': v.user.toJson(),
      'body': ?v.body,
      'state': v.state.name,
      'merged': v.merged,
      'mergeable_state': v.mergeState.name,
      'created_at': v.createdAt.toIso8601String(),
      'updated_at': ?v.updatedAt?.toIso8601String(),
      'closed_at': ?v.closedAt?.toIso8601String(),
      'merged_at': ?v.mergedAt?.toIso8601String(),
      'head': v.head.toJson(),
      'base': v.base.toJson(),
    };
  }

  PullRequest copyWith({
    int? id,
    int? number,
    String? title,
    SimpleUser? user,
    String? body,
    IssueState? state,
    bool? merged,
    MergeState? mergeState,
    DateTime? createdAt,
    DateTime? updatedAt,
    DateTime? closedAt,
    DateTime? mergedAt,
    BranchRef? head,
    BranchRef? base,
  }) {
    final v = this as PullRequest;
    return PullRequest(
      id: id ?? v.id,
      number: number ?? v.number,
      title: title ?? v.title,
      user: user ?? v.user,
      body: body ?? v.body,
      state: state ?? v.state,
      merged: merged ?? v.merged,
      mergeState: mergeState ?? v.mergeState,
      createdAt: createdAt ?? v.createdAt,
      updatedAt: updatedAt ?? v.updatedAt,
      closedAt: closedAt ?? v.closedAt,
      mergedAt: mergedAt ?? v.mergedAt,
      head: head ?? v.head,
      base: base ?? v.base,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as PullRequest;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is PullRequest &&
            (identical(other.id, v.id) || other.id == v.id) &&
            (identical(other.number, v.number) || other.number == v.number) &&
            (identical(other.title, v.title) || other.title == v.title) &&
            (identical(other.user, v.user) || other.user == v.user) &&
            (identical(other.body, v.body) || other.body == v.body) &&
            (identical(other.state, v.state) || other.state == v.state) &&
            (identical(other.merged, v.merged) || other.merged == v.merged) &&
            (identical(other.mergeState, v.mergeState) || other.mergeState == v.mergeState) &&
            (identical(other.createdAt, v.createdAt) || other.createdAt == v.createdAt) &&
            (identical(other.updatedAt, v.updatedAt) || other.updatedAt == v.updatedAt) &&
            (identical(other.closedAt, v.closedAt) || other.closedAt == v.closedAt) &&
            (identical(other.mergedAt, v.mergedAt) || other.mergedAt == v.mergedAt) &&
            (identical(other.head, v.head) || other.head == v.head) &&
            (identical(other.base, v.base) || other.base == v.base));
  }

  @override
  int get hashCode {
    final v = this as PullRequest;
    return Object.hash(
      runtimeType,
      v.id,
      v.number,
      v.title,
      v.user,
      v.body,
      v.state,
      v.merged,
      v.mergeState,
      v.createdAt,
      v.updatedAt,
      v.closedAt,
      v.mergedAt,
      v.head,
      v.base,
    );
  }

  @override
  String toString() {
    final v = this as PullRequest;
    return 'PullRequest{id: ${v.id}, number: ${v.number}, title: ${v.title}, user: ${v.user}, body: ${v.body}, state: ${v.state}, merged: ${v.merged}, mergeState: ${v.mergeState}, createdAt: ${v.createdAt}, updatedAt: ${v.updatedAt}, closedAt: ${v.closedAt}, mergedAt: ${v.mergedAt}, head: ${v.head}, base: ${v.base}}';
  }
}

mixin CommitUserData {
  static CommitUser fromJson(Map<String, dynamic> json) {
    return CommitUser(
      name: json['name'] as String,
      email: json['email'] as String,
      date: MacroExt.decodeDateTime(json['date']),
    );
  }

  Map<String, dynamic> toJson() {
    final v = this as CommitUser;
    return <String, dynamic>{
      'name': v.name,
      'email': v.email,
      'date': v.date.toIso8601String(),
    };
  }

  CommitUser copyWith({
    String? name,
    String? email,
    DateTime? date,
  }) {
    final v = this as CommitUser;
    return CommitUser(
      name: name ?? v.name,
      email: email ?? v.email,
      date: date ?? v.date,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as CommitUser;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CommitUser &&
            (identical(other.name, v.name) || other.name == v.name) &&
            (identical(other.email, v.email) || other.email == v.email) &&
            (identical(other.date, v.date) || other.date == v.date));
  }

  @override
  int get hashCode {
    final v = this as CommitUser;
    return Object.hash(
      runtimeType,
      v.name,
      v.email,
      v.date,
    );
  }

  @override
  String toString() {
    final v = this as CommitUser;
    return 'CommitUser{name: ${v.name}, email: ${v.email}, date: ${v.date}}';
  }
}

mixin GitCommitData {
  static GitCommit fromJson(Map<String, dynamic> json) {
    return GitCommit(
      sha: json['sha'] as String,
      message: json['message'] as String,
      author: CommitUserData.fromJson(json['author'] as Map<String, dynamic>),
      committer: CommitUserData.fromJson(json['committer'] as Map<String, dynamic>),
      parents: (json['parents'] as List<dynamic>).map((e) => e as String).toList(),
      treeSha: json['tree_sha'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final v = this as GitCommit;
    return <String, dynamic>{
      'sha': v.sha,
      'message': v.message,
      'author': v.author.toJson(),
      'committer': v.committer.toJson(),
      'parents': v.parents,
      'tree_sha': v.treeSha,
    };
  }

  GitCommit copyWith({
    String? sha,
    String? message,
    CommitUser? author,
    CommitUser? committer,
    List<String>? parents,
    String? treeSha,
  }) {
    final v = this as GitCommit;
    return GitCommit(
      sha: sha ?? v.sha,
      message: message ?? v.message,
      author: author ?? v.author,
      committer: committer ?? v.committer,
      parents: parents ?? v.parents,
      treeSha: treeSha ?? v.treeSha,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as GitCommit;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is GitCommit &&
            (identical(other.sha, v.sha) || other.sha == v.sha) &&
            (identical(other.message, v.message) || other.message == v.message) &&
            (identical(other.author, v.author) || other.author == v.author) &&
            (identical(other.committer, v.committer) || other.committer == v.committer) &&
            const DeepCollectionEquality().equals(other.parents, v.parents) &&
            (identical(other.treeSha, v.treeSha) || other.treeSha == v.treeSha));
  }

  @override
  int get hashCode {
    final v = this as GitCommit;
    return Object.hash(
      runtimeType,
      v.sha,
      v.message,
      v.author,
      v.committer,
      const DeepCollectionEquality().hash(v.parents),
      v.treeSha,
    );
  }

  @override
  String toString() {
    final v = this as GitCommit;
    return 'GitCommit{sha: ${v.sha}, message: ${v.message}, author: ${v.author}, committer: ${v.committer}, parents: ${v.parents}, treeSha: ${v.treeSha}}';
  }
}

mixin TreeEntryData {
  static TreeEntry fromJson(Map<String, dynamic> json) {
    return TreeEntry(
      path: json['path'] as String,
      mode: json['mode'] as String,
      type: MacroExt.decodeEnum(GitObjectType.values, json['type'], unknownValue: null),
      sha: json['sha'] as String,
      size: (json['size'] as num?)?.toInt(),
    );
  }

  Map<String, dynamic> toJson() {
    final v = this as TreeEntry;
    return <String, dynamic>{
      'path': v.path,
      'mode': v.mode,
      'type': v.type.name,
      'sha': v.sha,
      'size': ?v.size,
    };
  }

  TreeEntry copyWith({
    String? path,
    String? mode,
    GitObjectType? type,
    String? sha,
    int? size,
  }) {
    final v = this as TreeEntry;
    return TreeEntry(
      path: path ?? v.path,
      mode: mode ?? v.mode,
      type: type ?? v.type,
      sha: sha ?? v.sha,
      size: size ?? v.size,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as TreeEntry;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is TreeEntry &&
            (identical(other.path, v.path) || other.path == v.path) &&
            (identical(other.mode, v.mode) || other.mode == v.mode) &&
            (identical(other.type, v.type) || other.type == v.type) &&
            (identical(other.sha, v.sha) || other.sha == v.sha) &&
            (identical(other.size, v.size) || other.size == v.size));
  }

  @override
  int get hashCode {
    final v = this as TreeEntry;
    return Object.hash(
      runtimeType,
      v.path,
      v.mode,
      v.type,
      v.sha,
      v.size,
    );
  }

  @override
  String toString() {
    final v = this as TreeEntry;
    return 'TreeEntry{path: ${v.path}, mode: ${v.mode}, type: ${v.type}, sha: ${v.sha}, size: ${v.size}}';
  }
}

mixin GitTreeData {
  static GitTree fromJson(Map<String, dynamic> json) {
    return GitTree(
      sha: json['sha'] as String,
      url: json['url'] as String,
      tree: (json['tree'] as List<dynamic>).map((e) => TreeEntryData.fromJson(e as Map<String, dynamic>)).toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final v = this as GitTree;
    return <String, dynamic>{
      'sha': v.sha,
      'url': v.url,
      'tree': v.tree.map((e) => e.toJson()).toList(),
    };
  }

  GitTree copyWith({
    String? sha,
    String? url,
    List<TreeEntry>? tree,
  }) {
    final v = this as GitTree;
    return GitTree(
      sha: sha ?? v.sha,
      url: url ?? v.url,
      tree: tree ?? v.tree,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as GitTree;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is GitTree &&
            (identical(other.sha, v.sha) || other.sha == v.sha) &&
            (identical(other.url, v.url) || other.url == v.url) &&
            const DeepCollectionEquality().equals(other.tree, v.tree));
  }

  @override
  int get hashCode {
    final v = this as GitTree;
    return Object.hash(
      runtimeType,
      v.sha,
      v.url,
      const DeepCollectionEquality().hash(v.tree),
    );
  }

  @override
  String toString() {
    final v = this as GitTree;
    return 'GitTree{sha: ${v.sha}, url: ${v.url}, tree: ${v.tree}}';
  }
}

mixin GitBlobData {
  static GitBlob fromJson(Map<String, dynamic> json) {
    return GitBlob(
      sha: json['sha'] as String,
      size: (json['size'] as num).toInt(),
      encoding: json['encoding'] as String,
      content: json['content'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final v = this as GitBlob;
    return <String, dynamic>{
      'sha': v.sha,
      'size': v.size,
      'encoding': v.encoding,
      'content': v.content,
    };
  }

  GitBlob copyWith({
    String? sha,
    int? size,
    String? encoding,
    String? content,
  }) {
    final v = this as GitBlob;
    return GitBlob(
      sha: sha ?? v.sha,
      size: size ?? v.size,
      encoding: encoding ?? v.encoding,
      content: content ?? v.content,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as GitBlob;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is GitBlob &&
            (identical(other.sha, v.sha) || other.sha == v.sha) &&
            (identical(other.size, v.size) || other.size == v.size) &&
            (identical(other.encoding, v.encoding) || other.encoding == v.encoding) &&
            (identical(other.content, v.content) || other.content == v.content));
  }

  @override
  int get hashCode {
    final v = this as GitBlob;
    return Object.hash(
      runtimeType,
      v.sha,
      v.size,
      v.encoding,
      v.content,
    );
  }

  @override
  String toString() {
    final v = this as GitBlob;
    return 'GitBlob{sha: ${v.sha}, size: ${v.size}, encoding: ${v.encoding}, content: ${v.content}}';
  }
}

mixin RepoFullData {
  static RepoFull fromJson(Map<String, dynamic> json) {
    return RepoFull(
      repository: RepositoryData.fromJson(json['repository'] as Map<String, dynamic>),
      readme: json['readme'] == null ? null : GitBlobData.fromJson(json['readme'] as Map<String, dynamic>),
      latestCommit: json['latest_commit'] == null
          ? null
          : GitCommitData.fromJson(json['latest_commit'] as Map<String, dynamic>),
      issues: json['issues'] == null ? null : RepoFull.issuesFromJson(json['issues'] as Map<String, dynamic>?),
    );
  }

  Map<String, dynamic> toJson(Object? Function(Issue v) toJsonIssues) {
    final v = this as RepoFull;
    return <String, dynamic>{
      'repository': v.repository.toJson(),
      'readme': ?v.readme?.toJson(),
      'latest_commit': ?v.latestCommit?.toJson(),
      'issues': ?RepoFull.issuesToJson(v.issues),
    };
  }

  RepoFull copyWith({
    Repository? repository,
    GitBlob? readme,
    GitCommit? latestCommit,
    Paginated<Issue>? issues,
  }) {
    final v = this as RepoFull;
    return RepoFull(
      repository: repository ?? v.repository,
      readme: readme ?? v.readme,
      latestCommit: latestCommit ?? v.latestCommit,
      issues: issues ?? v.issues,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as RepoFull;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is RepoFull &&
            (identical(other.repository, v.repository) || other.repository == v.repository) &&
            (identical(other.readme, v.readme) || other.readme == v.readme) &&
            (identical(other.latestCommit, v.latestCommit) || other.latestCommit == v.latestCommit) &&
            (identical(other.issues, v.issues) || other.issues == v.issues));
  }

  @override
  int get hashCode {
    final v = this as RepoFull;
    return Object.hash(
      runtimeType,
      v.repository,
      v.readme,
      v.latestCommit,
      v.issues,
    );
  }

  @override
  String toString() {
    final v = this as RepoFull;
    return 'RepoFull{repository: ${v.repository}, readme: ${v.readme}, latestCommit: ${v.latestCommit}, issues: ${v.issues}}';
  }
}
