// coverage:ignore-file
// GENERATED BY Macro: DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark
// dart format off

part of 'import_complex.dart';

mixin MyProfileData {
  static MyProfile fromJson($c.Map<$c.String, $c.dynamic> json) {
    return MyProfile(
      info: MyProfile.infoFromJson(json['info'] as $c.Map<$c.String, $c.dynamic>),
      age: (json['age'] as $c.num).toInt(),
      lives: (json['lives'] as $c.num).toDouble(),
      livesNum: json['livesNum'] as $c.num,
      isDead: json['isDead'] as $c.bool,
      bigInt: $c.BigInt.parse(json['bigInt'] as $c.String),
      uri: $c.Uri.parse(json['uri'] as $c.String),
      symbol: $c.Symbol(json['symbol'] as $c.String),
      dynamicVal: json['dynamicVal'],
      myEnum: MacroExt.decodeEnum(MyEnum.values, json['myEnum'], unknownValue: null),
      address: json['address'] as $c.String,
      date: MacroExt.decodeDateTime(json['date']),
      duration: $c.Duration(microseconds: (json['duration'] as $c.num).toInt()),
      myIter: (json['myIter'] as $c.List<$c.dynamic>).map((e) => e as $c.String),
      myList: (json['myList'] as $c.List<$c.dynamic>).map((e) => e as $c.String).toList(),
      mySet: (json['mySet'] as $c.List<$c.dynamic>).map((e) => (e as $c.num).toInt()).toSet(),
      map1: (json['map1'] as $c.Map<$c.String, $c.dynamic>).map((k, e) => $c.MapEntry(k, (e as $c.num).toInt())),
      map2: (json['map2'] as $c.Map<$c.String, $c.dynamic>).map(
        (k, e) => $c.MapEntry(
          k,
          m.PersonData.fromJson((e as $c.Map<$c.String, $c.dynamic>).map((k, e) => $c.MapEntry(k, e))),
        ),
      ),
      future: MyProfile.futureFromJson(json['future'] as $c.Object?),
    );
  }

  $c.Map<$c.String, $c.dynamic> toJson() {
    final v = this as MyProfile;
    return <$c.String, $c.dynamic>{
      'info': v.info.toJson(),
      'age': v.age,
      'lives': v.lives,
      'livesNum': v.livesNum,
      'isDead': v.isDead,
      'bigInt': v.bigInt.toString(),
      'uri': v.uri.toString(),
      'symbol': v.symbol.toString(),
      'dynamicVal': v.dynamicVal,
      'myEnum': v.myEnum.name,
      'address': v.address,
      'date': v.date.toIso8601String(),
      'duration': v.duration.inMicroseconds,
      'myIter': v.myIter.toList(),
      'myList': v.myList,
      'mySet': v.mySet.map((e) => e).toList(),
      'map1': v.map1,
      'map2': v.map2.map((k, e) => $c.MapEntry(k, e.toJson())),
    };
  }

  MyProfile copyWith({
    m.Person? info,
    $c.int? age,
    $c.double? lives,
    $c.num? livesNum,
    $c.bool? isDead,
    $c.BigInt? bigInt,
    $c.Uri? uri,
    $c.Symbol? symbol,
    $c.dynamic dynamicVal,
    MyEnum? myEnum,
    $c.String? address,
    $c.DateTime? date,
    $c.Duration? duration,
    $c.Iterable<$c.String>? myIter,
    $c.List<$c.String>? myList,
    $c.Set<$c.int>? mySet,
    $c.Map<$c.String, $c.int>? map1,
    $c.Map<$c.String, m.Person>? map2,
    $c.Future<$c.String>? future,
  }) {
    final v = this as MyProfile;
    return MyProfile(
      info: info ?? v.info,
      age: age ?? v.age,
      lives: lives ?? v.lives,
      livesNum: livesNum ?? v.livesNum,
      isDead: isDead ?? v.isDead,
      bigInt: bigInt ?? v.bigInt,
      uri: uri ?? v.uri,
      symbol: symbol ?? v.symbol,
      dynamicVal: dynamicVal ?? v.dynamicVal,
      myEnum: myEnum ?? v.myEnum,
      address: address ?? v.address,
      date: date ?? v.date,
      duration: duration ?? v.duration,
      myIter: myIter ?? v.myIter,
      myList: myList ?? v.myList,
      mySet: mySet ?? v.mySet,
      map1: map1 ?? v.map1,
      map2: map2 ?? v.map2,
      future: future ?? v.future,
    );
  }

  @$c.override
  $c.bool operator ==($c.Object other) {
    final v = this as MyProfile;
    return $c.identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MyProfile &&
            ($c.identical(other.info, v.info) || other.info == v.info) &&
            ($c.identical(other.age, v.age) || other.age == v.age) &&
            ($c.identical(other.lives, v.lives) || other.lives == v.lives) &&
            ($c.identical(other.livesNum, v.livesNum) || other.livesNum == v.livesNum) &&
            ($c.identical(other.isDead, v.isDead) || other.isDead == v.isDead) &&
            ($c.identical(other.bigInt, v.bigInt) || other.bigInt == v.bigInt) &&
            ($c.identical(other.uri, v.uri) || other.uri == v.uri) &&
            ($c.identical(other.symbol, v.symbol) || other.symbol == v.symbol) &&
            ($c.identical(other.dynamicVal, v.dynamicVal) || other.dynamicVal == v.dynamicVal) &&
            ($c.identical(other.myEnum, v.myEnum) || other.myEnum == v.myEnum) &&
            ($c.identical(other.address, v.address) || other.address == v.address) &&
            ($c.identical(other.date, v.date) || other.date == v.date) &&
            ($c.identical(other.duration, v.duration) || other.duration == v.duration) &&
            const DeepCollectionEquality().equals(other.myIter, v.myIter) &&
            const DeepCollectionEquality().equals(other.myList, v.myList) &&
            const DeepCollectionEquality().equals(other.mySet, v.mySet) &&
            const DeepCollectionEquality().equals(other.map1, v.map1) &&
            const DeepCollectionEquality().equals(other.map2, v.map2) &&
            ($c.identical(other.future, v.future) || other.future == v.future));
  }

  @$c.override
  $c.int get hashCode {
    final v = this as MyProfile;
    return $c.Object.hash(
      runtimeType,
      v.info,
      v.age,
      v.lives,
      v.livesNum,
      v.isDead,
      v.bigInt,
      v.uri,
      v.symbol,
      v.dynamicVal,
      v.myEnum,
      v.address,
      v.date,
      v.duration,
      const DeepCollectionEquality().hash(v.myIter),
      const DeepCollectionEquality().hash(v.myList),
      const DeepCollectionEquality().hash(v.mySet),
      const DeepCollectionEquality().hash(v.map1),
      const DeepCollectionEquality().hash(v.map2),
      v.future,
    );
  }

  @$c.override
  $c.String toString() {
    final v = this as MyProfile;
    return 'MyProfile{info: ${v.info}, age: ${v.age}, lives: ${v.lives}, livesNum: ${v.livesNum}, isDead: ${v.isDead}, bigInt: ${v.bigInt}, uri: ${v.uri}, symbol: ${v.symbol}, dynamicVal: ${v.dynamicVal}, myEnum: ${v.myEnum}, address: ${v.address}, date: ${v.date}, duration: ${v.duration}, myIter: ${v.myIter}, myList: ${v.myList}, mySet: ${v.mySet}, map1: ${v.map1}, map2: ${v.map2}, future: ${v.future}}';
  }
}
