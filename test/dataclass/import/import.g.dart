// coverage:ignore-file
// GENERATED BY Macro: DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, unused_local_variable, unnecessary_overrides, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark
// dart format off

part of 'import.dart';

mixin MyProfileData {
  static MyProfile fromJson($c.Map<$c.String, $c.dynamic> json) {
    return MyProfile(
      info: m.PersonData.fromJson((json['info'] as $c.Map<$c.String, $c.dynamic>).map((k, e) => $c.MapEntry(k, e))),
      age: (json['age'] as $c.num).toInt(),
      address: json['address'] as $c.String,
      apple: f.AppleData.fromJson((json['apple'] as $c.Map<$c.String, $c.dynamic>).map((k, e) => $c.MapEntry(k, e))),
      bread: f.BreadData.fromJson((json['bread'] as $c.Map<$c.String, $c.dynamic>).map((k, e) => $c.MapEntry(k, e))),
      cake: f.CakeData.fromJson((json['cake'] as $c.Map<$c.String, $c.dynamic>).map((k, e) => $c.MapEntry(k, e))),
      myEnum: MacroExt.decodeEnum(m.MyEnum.values, json['myEnum'], unknownValue: null),
    );
  }

  $c.Map<$c.String, $c.dynamic> toJson() {
    final v = this as MyProfile;
    return <$c.String, $c.dynamic>{
      'info': v.info.toJson(),
      'age': v.age,
      'address': v.address,
      'apple': v.apple.toJson(),
      'bread': v.bread.toJson(),
      'cake': v.cake.toJson(),
      'myEnum': v.myEnum.name,
    };
  }

  MyProfile copyWith({
    m.Person? info,
    $c.int? age,
    $c.String? address,
    f.Apple? apple,
    f.Bread? bread,
    f.Cake? cake,
    m.MyEnum? myEnum,
  }) {
    final v = this as MyProfile;
    return MyProfile(
      info: info ?? v.info,
      age: age ?? v.age,
      address: address ?? v.address,
      apple: apple ?? v.apple,
      bread: bread ?? v.bread,
      cake: cake ?? v.cake,
      myEnum: myEnum ?? v.myEnum,
    );
  }

  @$c.override
  $c.bool operator ==($c.Object other) {
    final v = this as MyProfile;
    return $c.identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MyProfile &&
            ($c.identical(other.info, v.info) || other.info == v.info) &&
            ($c.identical(other.age, v.age) || other.age == v.age) &&
            ($c.identical(other.address, v.address) || other.address == v.address) &&
            ($c.identical(other.apple, v.apple) || other.apple == v.apple) &&
            ($c.identical(other.bread, v.bread) || other.bread == v.bread) &&
            ($c.identical(other.cake, v.cake) || other.cake == v.cake) &&
            ($c.identical(other.myEnum, v.myEnum) || other.myEnum == v.myEnum));
  }

  @$c.override
  $c.int get hashCode {
    final v = this as MyProfile;
    return $c.Object.hash(
      runtimeType,
      v.info,
      v.age,
      v.address,
      v.apple,
      v.bread,
      v.cake,
      v.myEnum,
    );
  }

  @$c.override
  $c.String toString() {
    final v = this as MyProfile;
    return 'MyProfile{info: ${v.info}, age: ${v.age}, address: ${v.address}, apple: ${v.apple}, bread: ${v.bread}, cake: ${v.cake}, myEnum: ${v.myEnum}}';
  }
}

mixin AnimalData {
  static Animal fromJson<CowDataType>(
    $c.Map<$c.String, $c.dynamic> json, {
    required CowDataType Function($c.Object? v) fromJsonCowDataType,
  }) {
    final type = json['type'];
    return switch (type) {
      'Cat' => CatData.fromJson(json),
      'BigCow' => CowData.fromJson<CowDataType>(json, fromJsonCowDataType),
      'Dog' => DogData.fromJson(json),
      _ => throw InvalidDiscriminatorException(
        'Unrecognized discriminator value "$type" for Animal. No default subtype is defined.',
      ),
    };
  }

  $c.Map<$c.String, $c.dynamic> toJsonBy<CowDataType>({
    required $c.Object? Function(CowDataType value) toJsonCowDataType,
  }) {
    return switch (this) {
      Cat v => v.toJson(),
      Cow<CowDataType> v => v.toJson(toJsonCowDataType),
      Dog v => v.toJson(),
      _ => throw InvalidDiscriminatorException('Unrecognized discriminator value "$runtimeType" for Animal.'),
    };
  }

  Res map<CowDataType, Res>({
    required Res Function(Cat value) cat,
    required Res Function(Cow<CowDataType> value) cow,
    required Res Function(Dog value) dog,
    Res Function(Animal value)? fallback,
  }) {
    return switch (this) {
      Cat v => cat(v),
      Cow<CowDataType> v => cow(v),
      Dog v => dog(v),
      _ when fallback != null => fallback(this as Animal),
      _ => throw InvalidDiscriminatorException('Unrecognized discriminator value "$runtimeType" for Animal.'),
    };
  }

  Res? mapOrNull<CowDataType, Res>({
    Res? Function(Cat value)? cat,
    Res? Function(Cow<CowDataType> value)? cow,
    Res? Function(Dog value)? dog,
  }) {
    return switch (this) {
      Cat v => cat?.call(v),
      Cow<CowDataType> v => cow?.call(v),
      Dog v => dog?.call(v),
      _ => null,
    };
  }

  Animal copyWithBy<CowDataType>({
    Cat Function(Cat value)? cat,
    Cow<CowDataType> Function(Cow<CowDataType> value)? cow,
    Dog Function(Dog value)? dog,
  }) {
    return switch (this) {
      Cat v => cat != null ? cat(v) : v.copyWith(),
      Cow<CowDataType> v => cow != null ? cow(v) : v.copyWith(),
      Dog v => dog != null ? dog(v) : v.copyWith(),
      _ => throw InvalidDiscriminatorException('Unrecognized discriminator value "$runtimeType" for Animal.'),
    };
  }

  @$c.pragma('vm:prefer-inline')
  Cat asCat() {
    return this as Cat;
  }

  @$c.pragma('vm:prefer-inline')
  Cow<CowDataType> asCow<CowDataType>() {
    return this as Cow<CowDataType>;
  }

  @$c.pragma('vm:prefer-inline')
  Dog asDog() {
    return this as Dog;
  }
}

mixin DogData {
  static Dog fromJson($c.Map<$c.String, $c.dynamic> json) {
    return Dog(
      name: json['name'] as $c.String,
      breed: json['breed'] as $c.String,
    );
  }

  $c.Map<$c.String, $c.dynamic> toJson() {
    final v = this as Dog;
    return <$c.String, $c.dynamic>{
      'name': v.name,
      'breed': v.breed,
      'type': 'Dog',
    };
  }

  Dog copyWith({
    $c.String? name,
    $c.String? breed,
  }) {
    final v = this as Dog;
    return Dog(
      name: name ?? v.name,
      breed: breed ?? v.breed,
    );
  }

  @$c.override
  $c.bool operator ==($c.Object other) {
    final v = this as Dog;
    return $c.identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Dog &&
            ($c.identical(other.name, v.name) || other.name == v.name) &&
            ($c.identical(other.breed, v.breed) || other.breed == v.breed));
  }

  @$c.override
  $c.int get hashCode {
    final v = this as Dog;
    return $c.Object.hash(
      runtimeType,
      v.name,
      v.breed,
    );
  }

  @$c.override
  $c.String toString() {
    final v = this as Dog;
    return 'Dog{name: ${v.name}, breed: ${v.breed}}';
  }
}

mixin CatData {
  static Cat fromJson($c.Map<$c.String, $c.dynamic> json) {
    return Cat(
      name: json['name'] as $c.String,
      lives: (json['lives'] as $c.num).toInt(),
    );
  }

  $c.Map<$c.String, $c.dynamic> toJson() {
    final v = this as Cat;
    return <$c.String, $c.dynamic>{
      'name': v.name,
      'lives': v.lives,
      'type': 'Cat',
    };
  }

  Cat copyWith({
    $c.String? name,
    $c.int? lives,
  }) {
    final v = this as Cat;
    return Cat(
      name: name ?? v.name,
      lives: lives ?? v.lives,
    );
  }

  @$c.override
  $c.bool operator ==($c.Object other) {
    final v = this as Cat;
    return $c.identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Cat &&
            ($c.identical(other.name, v.name) || other.name == v.name) &&
            ($c.identical(other.lives, v.lives) || other.lives == v.lives));
  }

  @$c.override
  $c.int get hashCode {
    final v = this as Cat;
    return $c.Object.hash(
      runtimeType,
      v.name,
      v.lives,
    );
  }

  @$c.override
  $c.String toString() {
    final v = this as Cat;
    return 'Cat{name: ${v.name}, lives: ${v.lives}}';
  }
}

mixin CowData<CowDataType> {
  static Cow<CowDataType> fromJson<CowDataType>(
    $c.Map<$c.String, $c.dynamic> json,
    CowDataType Function($c.Object? v) fromJsonCowDataType,
  ) {
    return Cow<CowDataType>(
      name: json['name'] as $c.String,
      data: fromJsonCowDataType(json['data']),
    );
  }

  $c.Map<$c.String, $c.dynamic> toJson($c.Object? Function(CowDataType v) toJsonCowDataType) {
    final v = this as Cow<CowDataType>;
    return <$c.String, $c.dynamic>{
      'name': v.name,
      'data': toJsonCowDataType(v.data),
      'type': 'BigCow',
    };
  }

  Cow<CowDataType> copyWith({
    $c.String? name,
    CowDataType? data,
  }) {
    final v = this as Cow<CowDataType>;
    return Cow<CowDataType>(
      name: name ?? v.name,
      data: data ?? v.data,
    );
  }

  @$c.override
  $c.bool operator ==($c.Object other) {
    final v = this as Cow<CowDataType>;
    return $c.identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Cow<CowDataType> &&
            ($c.identical(other.name, v.name) || other.name == v.name) &&
            ($c.identical(other.data, v.data) || other.data == v.data));
  }

  @$c.override
  $c.int get hashCode {
    final v = this as Cow<CowDataType>;
    return $c.Object.hash(
      runtimeType,
      v.name,
      v.data,
    );
  }

  @$c.override
  $c.String toString() {
    final v = this as Cow<CowDataType>;
    return 'Cow<$CowDataType>{name: ${v.name}, data: ${v.data}}';
  }
}

mixin GenericData<T> {
  static Generic<T> fromJson<T>($c.Map<$c.String, $c.dynamic> json, T Function($c.Object? v) fromJsonT) {
    return Generic<T>(
      data: fromJsonT(json['data']),
    );
  }

  $c.Map<$c.String, $c.dynamic> toJson($c.Object? Function(T v) toJsonT) {
    final v = this as Generic<T>;
    return <$c.String, $c.dynamic>{
      'data': toJsonT(v.data),
    };
  }

  Generic<T> copyWith({
    T? data,
  }) {
    final v = this as Generic<T>;
    return Generic<T>(
      data: data ?? v.data,
    );
  }

  @$c.override
  $c.bool operator ==($c.Object other) {
    final v = this as Generic<T>;
    return $c.identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Generic<T> &&
            ($c.identical(other.data, v.data) || other.data == v.data));
  }

  @$c.override
  $c.int get hashCode {
    final v = this as Generic<T>;
    return $c.Object.hash(
      runtimeType,
      v.data,
    );
  }

  @$c.override
  $c.String toString() {
    final v = this as Generic<T>;
    return 'Generic<$T>{data: ${v.data}}';
  }
}

mixin TupleModelData {
  static TupleModel fromJson($c.Map<$c.String, $c.dynamic> json) {
    return TupleModel(
      value1: (
        (json['value1']['\$1'] as $c.num).toInt(),
        (json['value1']['\$2'] as $c.num).toInt(),
      ),
    );
  }

  $c.Map<$c.String, $c.dynamic> toJson() {
    final v = this as TupleModel;
    return <$c.String, $c.dynamic>{
      'value1': <$c.String, $c.dynamic>{
        '\$1': v.value1.$1,
        '\$2': v.value1.$2,
      },
    };
  }

  TupleModel copyWith({
    m.MyData? value1,
  }) {
    final v = this as TupleModel;
    return TupleModel(
      value1: value1 ?? v.value1,
    );
  }

  @$c.override
  $c.bool operator ==($c.Object other) {
    final v = this as TupleModel;
    return $c.identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is TupleModel &&
            ($c.identical(other.value1, v.value1) || other.value1 == v.value1));
  }

  @$c.override
  $c.int get hashCode {
    final v = this as TupleModel;
    return $c.Object.hash(
      runtimeType,
      v.value1,
    );
  }

  @$c.override
  $c.String toString() {
    final v = this as TupleModel;
    return 'TupleModel{value1: ${v.value1}}';
  }
}
