// coverage:ignore-file
// GENERATED BY Macro: DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, unused_local_variable, unnecessary_overrides, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark
// dart format off

part of 'extends_sealed_test.dart';

mixin BrandData {
  static Brand fromJson(Map<String, dynamic> json) {
    return Brand(
      json['name'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final v = this as Brand;
    return <String, dynamic>{
      'name': v.name,
    };
  }

  Brand copyWith({
    String? name,
  }) {
    final v = this as Brand;
    return Brand(
      name ?? v.name,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as Brand;
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is Brand && (identical(other.name, v.name) || other.name == v.name));
  }

  @override
  int get hashCode {
    final v = this as Brand;
    return Object.hash(
      runtimeType,
      v.name,
    );
  }

  @override
  String toString() {
    final v = this as Brand;
    return 'Brand{name: ${v.name}}';
  }
}

mixin CarData {
  static Car fromJson(Map<String, dynamic> json) {
    return Car(
      json['brand'] == null ? null : BrandData.fromJson(json['brand'] as Map<String, dynamic>),
      json['model'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final v = this as Car;
    return <String, dynamic>{
      'brand': ?v.brand?.toJson(),
      'model': v.model,
    };
  }

  Car copyWith({
    Brand? brand,
    String? model,
  }) {
    final v = this as Car;
    return Car(
      brand ?? v.brand,
      model ?? v.model,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as Car;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Car &&
            (identical(other.brand, v.brand) || other.brand == v.brand) &&
            (identical(other.model, v.model) || other.model == v.model));
  }

  @override
  int get hashCode {
    final v = this as Car;
    return Object.hash(
      runtimeType,
      v.brand,
      v.model,
    );
  }

  @override
  String toString() {
    final v = this as Car;
    return 'Car{brand: ${v.brand}, model: ${v.model}}';
  }
}

mixin PersonData {
  static Person fromJson(Map<String, dynamic> json) {
    return Person(
      json['name'] as String,
      CarData.fromJson(json['car'] as Map<String, dynamic>),
    );
  }

  Map<String, dynamic> toJson() {
    final v = this as Person;
    return <String, dynamic>{
      'name': v.name,
      'car': v.car.toJson(),
    };
  }

  Person copyWith({
    String? name,
    Car? car,
  }) {
    final v = this as Person;
    return Person(
      name ?? v.name,
      car ?? v.car,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as Person;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Person &&
            (identical(other.name, v.name) || other.name == v.name) &&
            (identical(other.car, v.car) || other.car == v.car));
  }

  @override
  int get hashCode {
    final v = this as Person;
    return Object.hash(
      runtimeType,
      v.name,
      v.car,
    );
  }

  @override
  String toString() {
    final v = this as Person;
    return 'Person{name: ${v.name}, car: ${v.car}}';
  }
}

mixin ItemListData<T> {
  static ItemList<T> fromJson<T, T$ extends Comparable<T$>, T1 extends Map<String, T2>, T2, K, T$$, T$$$>(
    Map<String, dynamic> json, {
    required T$ Function(Object? v) fromJsonT$,
    required T1 Function(Object? v) fromJsonT1,
    required T2 Function(Object? v) fromJsonT2,
    required K Function(Object? v) fromJsonK,
    required T$$ Function(Object? v) fromJsonT$$,
    required T$$$ Function(Object? v) fromJsonT$$$,
  }) {
    final type = json['type'];
    return switch (type) {
          'BrandList' => BrandListData.fromJson(json),
          'ComparableItemList' => ComparableItemListData.fromJson<T$>(json, fromJsonT$),
          'ComparableItemList1' => ComparableItemList1Data.fromJson<T1, T2>(json, fromJsonT1, fromJsonT2),
          'KeyedItemList' => KeyedItemListData.fromJson<K, T$$>(json, fromJsonK, fromJsonT$$),
          'NamedItemList' => NamedItemListData.fromJson<T$$$>(json, fromJsonT$$$),
          _ => throw InvalidDiscriminatorException(
            'Unrecognized discriminator value "$type" for ItemList. No default subtype is defined.',
          ),
        }
        as ItemList<T>;
  }

  Map<String, dynamic> toJsonBy<T$ extends Comparable<T$>, T1 extends Map<String, T2>, T2, K, T$$, T$$$>({
    required Object? Function(T$ value) toJsonT$,
    required Object? Function(T1 value) toJsonT1,
    required Object? Function(T2 value) toJsonT2,
    required Object? Function(K value) toJsonK,
    required Object? Function(T$$ value) toJsonT$$,
    required Object? Function(T$$$ value) toJsonT$$$,
  }) {
    return switch (this) {
      BrandList v => v.toJson(),
      ComparableItemList<T$> v => v.toJson(toJsonT$),
      ComparableItemList1<T1, T2> v => v.toJson(toJsonT1, toJsonT2),
      KeyedItemList<K, T$$> v => v.toJson(toJsonK, toJsonT$$),
      NamedItemList<T$$$> v => v.toJson(toJsonT$$$),
      _ => throw InvalidDiscriminatorException('Unrecognized discriminator value "$runtimeType" for ItemList.'),
    };
  }

  Res map<T$ extends Comparable<T$>, T1 extends Map<String, T2>, T2, K, T$$, T$$$, Res>({
    required Res Function(BrandList value) brandList,
    required Res Function(ComparableItemList<T$> value) comparableItemList,
    required Res Function(ComparableItemList1<T1, T2> value) comparableItemList1,
    required Res Function(KeyedItemList<K, T$$> value) keyedItemList,
    required Res Function(NamedItemList<T$$$> value) namedItemList,
    Res Function(ItemList<T> value)? fallback,
  }) {
    return switch (this) {
      BrandList v => brandList(v),
      ComparableItemList<T$> v => comparableItemList(v),
      ComparableItemList1<T1, T2> v => comparableItemList1(v),
      KeyedItemList<K, T$$> v => keyedItemList(v),
      NamedItemList<T$$$> v => namedItemList(v),
      _ when fallback != null => fallback(this as ItemList<T>),
      _ => throw InvalidDiscriminatorException('Unrecognized discriminator value "$runtimeType" for ItemList.'),
    };
  }

  Res? mapOrNull<T$ extends Comparable<T$>, T1 extends Map<String, T2>, T2, K, T$$, T$$$, Res>({
    Res? Function(BrandList value)? brandList,
    Res? Function(ComparableItemList<T$> value)? comparableItemList,
    Res? Function(ComparableItemList1<T1, T2> value)? comparableItemList1,
    Res? Function(KeyedItemList<K, T$$> value)? keyedItemList,
    Res? Function(NamedItemList<T$$$> value)? namedItemList,
  }) {
    return switch (this) {
      BrandList v => brandList?.call(v),
      ComparableItemList<T$> v => comparableItemList?.call(v),
      ComparableItemList1<T1, T2> v => comparableItemList1?.call(v),
      KeyedItemList<K, T$$> v => keyedItemList?.call(v),
      NamedItemList<T$$$> v => namedItemList?.call(v),
      _ => null,
    };
  }

  ItemList<T> copyWithBy<T$ extends Comparable<T$>, T1 extends Map<String, T2>, T2, K, T$$, T$$$>({
    BrandList Function(BrandList value)? brandList,
    ComparableItemList<T$> Function(ComparableItemList<T$> value)? comparableItemList,
    ComparableItemList1<T1, T2> Function(ComparableItemList1<T1, T2> value)? comparableItemList1,
    KeyedItemList<K, T$$> Function(KeyedItemList<K, T$$> value)? keyedItemList,
    NamedItemList<T$$$> Function(NamedItemList<T$$$> value)? namedItemList,
  }) {
    return switch (this) {
          BrandList v => brandList != null ? brandList(v) : v.copyWith(),
          ComparableItemList<T$> v => comparableItemList != null ? comparableItemList(v) : v.copyWith(),
          ComparableItemList1<T1, T2> v => comparableItemList1 != null ? comparableItemList1(v) : v.copyWith(),
          KeyedItemList<K, T$$> v => keyedItemList != null ? keyedItemList(v) : v.copyWith(),
          NamedItemList<T$$$> v => namedItemList != null ? namedItemList(v) : v.copyWith(),
          _ => throw InvalidDiscriminatorException('Unrecognized discriminator value "$runtimeType" for ItemList.'),
        }
        as ItemList<T>;
  }

  @pragma('vm:prefer-inline')
  BrandList asBrandList() {
    return this as BrandList;
  }

  @pragma('vm:prefer-inline')
  ComparableItemList<T$> asComparableItemList<T$ extends Comparable<T$>>() {
    return this as ComparableItemList<T$>;
  }

  @pragma('vm:prefer-inline')
  ComparableItemList1<T1, T2> asComparableItemList1<T1 extends Map<String, T2>, T2>() {
    return this as ComparableItemList1<T1, T2>;
  }

  @pragma('vm:prefer-inline')
  KeyedItemList<K, T$$> asKeyedItemList<K, T$$>() {
    return this as KeyedItemList<K, T$$>;
  }

  @pragma('vm:prefer-inline')
  NamedItemList<T$$$> asNamedItemList<T$$$>() {
    return this as NamedItemList<T$$$>;
  }
}

mixin BrandListData {
  static BrandList fromJson(Map<String, dynamic> json) {
    return BrandList(
      (json['items'] as List<dynamic>?)
          ?.map((e) => e == null ? null : BrandData.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final v = this as BrandList;
    return <String, dynamic>{
      'items': v.items2.map((e) => e?.toJson()).toList(),
      'type': 'BrandList',
    };
  }

  BrandList copyWith({
    List<Brand?>? items2,
  }) {
    final v = this as BrandList;
    return BrandList(
      items2 ?? v.items2,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as BrandList;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is BrandList &&
            const DeepCollectionEquality().equals(other.items2, v.items2));
  }

  @override
  int get hashCode {
    final v = this as BrandList;
    return Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(v.items2),
    );
  }

  @override
  String toString() {
    final v = this as BrandList;
    return 'BrandList{items: ${v.items2}}';
  }
}

mixin NamedItemListData<T> {
  static NamedItemList<T> fromJson<T>(Map<String, dynamic> json, T Function(Object? v) fromJsonT) {
    return NamedItemList<T>(
      json['name'] as String,
      (json['items'] as List<dynamic>?)?.map((e) => fromJsonT(e)).toList(),
    );
  }

  Map<String, dynamic> toJson(Object? Function(T v) toJsonT) {
    final v = this as NamedItemList<T>;
    return <String, dynamic>{
      'name': v.name,
      'items': v.items2.map((e) => toJsonT(e)).toList(),
      'type': 'NamedItemList',
    };
  }

  NamedItemList<T> copyWith({
    String? name,
    List<T>? items2,
  }) {
    final v = this as NamedItemList<T>;
    return NamedItemList<T>(
      name ?? v.name,
      items2 ?? v.items2,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as NamedItemList<T>;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is NamedItemList<T> &&
            (identical(other.name, v.name) || other.name == v.name) &&
            const DeepCollectionEquality().equals(other.items2, v.items2));
  }

  @override
  int get hashCode {
    final v = this as NamedItemList<T>;
    return Object.hash(
      runtimeType,
      v.name,
      const DeepCollectionEquality().hash(v.items2),
    );
  }

  @override
  String toString() {
    final v = this as NamedItemList<T>;
    return 'NamedItemList<$T>{name: ${v.name}, items: ${v.items2}}';
  }
}

mixin KeyedItemListData<K, T> {
  static KeyedItemList<K, T> fromJson<K, T>(
    Map<String, dynamic> json,
    K Function(Object? v) fromJsonK,
    T Function(Object? v) fromJsonT,
  ) {
    return KeyedItemList<K, T>(
      fromJsonK(json['key']),
      (json['items'] as List<dynamic>?)?.map((e) => fromJsonT(e)).toList(),
    );
  }

  Map<String, dynamic> toJson(Object? Function(K v) toJsonK, Object? Function(T v) toJsonT) {
    final v = this as KeyedItemList<K, T>;
    return <String, dynamic>{
      'key': toJsonK(v.key),
      'items': v.items2.map((e) => toJsonT(e)).toList(),
      'type': 'KeyedItemList',
    };
  }

  KeyedItemList<K, T> copyWith({
    K? key,
    List<T>? items2,
  }) {
    final v = this as KeyedItemList<K, T>;
    return KeyedItemList<K, T>(
      key ?? v.key,
      items2 ?? v.items2,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as KeyedItemList<K, T>;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is KeyedItemList<K, T> &&
            (identical(other.key, v.key) || other.key == v.key) &&
            const DeepCollectionEquality().equals(other.items2, v.items2));
  }

  @override
  int get hashCode {
    final v = this as KeyedItemList<K, T>;
    return Object.hash(
      runtimeType,
      v.key,
      const DeepCollectionEquality().hash(v.items2),
    );
  }

  @override
  String toString() {
    final v = this as KeyedItemList<K, T>;
    return 'KeyedItemList<$K,T>{key: ${v.key}, items: ${v.items2}}';
  }
}

mixin ComparableItemListData<T extends Comparable<T>> {
  static ComparableItemList<T> fromJson<T extends Comparable<T>>(
    Map<String, dynamic> json,
    T Function(Object? v) fromJsonT,
  ) {
    return ComparableItemList<T>(
      (json['items'] as List<dynamic>?)?.map((e) => fromJsonT(e)).toList(),
    );
  }

  Map<String, dynamic> toJson(Object? Function(T v) toJsonT) {
    final v = this as ComparableItemList<T>;
    return <String, dynamic>{
      'items': v.items2.map((e) => toJsonT(e)).toList(),
      'type': 'ComparableItemList',
    };
  }

  ComparableItemList<T> copyWith({
    List<T>? items2,
  }) {
    final v = this as ComparableItemList<T>;
    return ComparableItemList<T>(
      items2 ?? v.items2,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as ComparableItemList<T>;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ComparableItemList<T> &&
            const DeepCollectionEquality().equals(other.items2, v.items2));
  }

  @override
  int get hashCode {
    final v = this as ComparableItemList<T>;
    return Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(v.items2),
    );
  }

  @override
  String toString() {
    final v = this as ComparableItemList<T>;
    return 'ComparableItemList<$T>{items: ${v.items2}}';
  }
}

mixin ComparableItemList1Data<T1 extends Map<String, T2>, T2> {
  static ComparableItemList1<T1, T2> fromJson<T1 extends Map<String, T2>, T2>(
    Map<String, dynamic> json,
    T1 Function(Object? v) fromJsonT1,
    T2 Function(Object? v) fromJsonT2,
  ) {
    return ComparableItemList1<T1, T2>(
      (json['items'] as List<dynamic>?)?.map((e) => e as String).toList(),
    );
  }

  Map<String, dynamic> toJson(Object? Function(T1 v) toJsonT1, Object? Function(T2 v) toJsonT2) {
    final v = this as ComparableItemList1<T1, T2>;
    return <String, dynamic>{
      'items': v.items2,
      'type': 'ComparableItemList1',
    };
  }

  ComparableItemList1<T1, T2> copyWith({
    List<String>? items2,
  }) {
    final v = this as ComparableItemList1<T1, T2>;
    return ComparableItemList1<T1, T2>(
      items2 ?? v.items2,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as ComparableItemList1<T1, T2>;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ComparableItemList1<T1, T2> &&
            const DeepCollectionEquality().equals(other.items2, v.items2));
  }

  @override
  int get hashCode {
    final v = this as ComparableItemList1<T1, T2>;
    return Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(v.items2),
    );
  }

  @override
  String toString() {
    final v = this as ComparableItemList1<T1, T2>;
    return 'ComparableItemList1<$T1,T2>{items: ${v.items2}}';
  }
}

mixin ItemList1Data<T> {
  static ItemList1<T> fromJson<T, T$ extends Comparable<T$>, T1 extends Map<String, T2>, T2, K, T$$, T$$$>(
    Map<String, dynamic> json, {
    required T$ Function(Object? v) fromJsonT$,
    required T1 Function(Object? v) fromJsonT1,
    required T2 Function(Object? v) fromJsonT2,
    required K Function(Object? v) fromJsonK,
    required T$$ Function(Object? v) fromJsonT$$,
    required T$$$ Function(Object? v) fromJsonT$$$,
  }) {
    final type = json['type'];
    return switch (type) {
          'BrandList1' => BrandList1Data.fromJson(json),
          'ComparableItemList2' => ComparableItemList2Data.fromJson<T$>(json, fromJsonT$),
          'ComparableItemList3' => ComparableItemList3Data.fromJson<T1, T2>(json, fromJsonT1, fromJsonT2),
          'KeyedItemList1' => KeyedItemList1Data.fromJson<K, T$$>(json, fromJsonK, fromJsonT$$),
          'NamedItemList1' => NamedItemList1Data.fromJson<T$$$>(json, fromJsonT$$$),
          _ => throw InvalidDiscriminatorException(
            'Unrecognized discriminator value "$type" for ItemList1. No default subtype is defined.',
          ),
        }
        as ItemList1<T>;
  }

  Map<String, dynamic> toJsonBy<T$ extends Comparable<T$>, T1 extends Map<String, T2>, T2, K, T$$, T$$$>({
    required Object? Function(T$ value) toJsonT$,
    required Object? Function(T1 value) toJsonT1,
    required Object? Function(T2 value) toJsonT2,
    required Object? Function(K value) toJsonK,
    required Object? Function(T$$ value) toJsonT$$,
    required Object? Function(T$$$ value) toJsonT$$$,
  }) {
    return switch (this) {
      BrandList1 v => v.toJson(),
      ComparableItemList2<T$> v => v.toJson(toJsonT$),
      ComparableItemList3<T1, T2> v => v.toJson(toJsonT1, toJsonT2),
      KeyedItemList1<K, T$$> v => v.toJson(toJsonK, toJsonT$$),
      NamedItemList1<T$$$> v => v.toJson(toJsonT$$$),
      _ => throw InvalidDiscriminatorException('Unrecognized discriminator value "$runtimeType" for ItemList1.'),
    };
  }

  Res map<T$ extends Comparable<T$>, T1 extends Map<String, T2>, T2, K, T$$, T$$$, Res>({
    required Res Function(BrandList1 value) brandList1,
    required Res Function(ComparableItemList2<T$> value) comparableItemList2,
    required Res Function(ComparableItemList3<T1, T2> value) comparableItemList3,
    required Res Function(KeyedItemList1<K, T$$> value) keyedItemList1,
    required Res Function(NamedItemList1<T$$$> value) namedItemList1,
    Res Function(ItemList1<T> value)? fallback,
  }) {
    return switch (this) {
      BrandList1 v => brandList1(v),
      ComparableItemList2<T$> v => comparableItemList2(v),
      ComparableItemList3<T1, T2> v => comparableItemList3(v),
      KeyedItemList1<K, T$$> v => keyedItemList1(v),
      NamedItemList1<T$$$> v => namedItemList1(v),
      _ when fallback != null => fallback(this as ItemList1<T>),
      _ => throw InvalidDiscriminatorException('Unrecognized discriminator value "$runtimeType" for ItemList1.'),
    };
  }

  Res? mapOrNull<T$ extends Comparable<T$>, T1 extends Map<String, T2>, T2, K, T$$, T$$$, Res>({
    Res? Function(BrandList1 value)? brandList1,
    Res? Function(ComparableItemList2<T$> value)? comparableItemList2,
    Res? Function(ComparableItemList3<T1, T2> value)? comparableItemList3,
    Res? Function(KeyedItemList1<K, T$$> value)? keyedItemList1,
    Res? Function(NamedItemList1<T$$$> value)? namedItemList1,
  }) {
    return switch (this) {
      BrandList1 v => brandList1?.call(v),
      ComparableItemList2<T$> v => comparableItemList2?.call(v),
      ComparableItemList3<T1, T2> v => comparableItemList3?.call(v),
      KeyedItemList1<K, T$$> v => keyedItemList1?.call(v),
      NamedItemList1<T$$$> v => namedItemList1?.call(v),
      _ => null,
    };
  }

  ItemList1<T> copyWithBy<T$ extends Comparable<T$>, T1 extends Map<String, T2>, T2, K, T$$, T$$$>({
    BrandList1 Function(BrandList1 value)? brandList1,
    ComparableItemList2<T$> Function(ComparableItemList2<T$> value)? comparableItemList2,
    ComparableItemList3<T1, T2> Function(ComparableItemList3<T1, T2> value)? comparableItemList3,
    KeyedItemList1<K, T$$> Function(KeyedItemList1<K, T$$> value)? keyedItemList1,
    NamedItemList1<T$$$> Function(NamedItemList1<T$$$> value)? namedItemList1,
  }) {
    return switch (this) {
          BrandList1 v => brandList1 != null ? brandList1(v) : v.copyWith(),
          ComparableItemList2<T$> v => comparableItemList2 != null ? comparableItemList2(v) : v.copyWith(),
          ComparableItemList3<T1, T2> v => comparableItemList3 != null ? comparableItemList3(v) : v.copyWith(),
          KeyedItemList1<K, T$$> v => keyedItemList1 != null ? keyedItemList1(v) : v.copyWith(),
          NamedItemList1<T$$$> v => namedItemList1 != null ? namedItemList1(v) : v.copyWith(),
          _ => throw InvalidDiscriminatorException('Unrecognized discriminator value "$runtimeType" for ItemList1.'),
        }
        as ItemList1<T>;
  }

  @pragma('vm:prefer-inline')
  BrandList1 asBrandList1() {
    return this as BrandList1;
  }

  @pragma('vm:prefer-inline')
  ComparableItemList2<T$> asComparableItemList2<T$ extends Comparable<T$>>() {
    return this as ComparableItemList2<T$>;
  }

  @pragma('vm:prefer-inline')
  ComparableItemList3<T1, T2> asComparableItemList3<T1 extends Map<String, T2>, T2>() {
    return this as ComparableItemList3<T1, T2>;
  }

  @pragma('vm:prefer-inline')
  KeyedItemList1<K, T$$> asKeyedItemList1<K, T$$>() {
    return this as KeyedItemList1<K, T$$>;
  }

  @pragma('vm:prefer-inline')
  NamedItemList1<T$$$> asNamedItemList1<T$$$>() {
    return this as NamedItemList1<T$$$>;
  }
}

mixin BrandList1Data {
  static BrandList1 fromJson(Map<String, dynamic> json) {
    return BrandList1(
      (json['items'] as List<dynamic>?)
          ?.map((e) => e == null ? null : BrandData.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final v = this as BrandList1;
    return <String, dynamic>{
      'items': v.items2.map((e) => e?.toJson()).toList(),
      'type': 'BrandList1',
    };
  }

  BrandList1 copyWith({
    List<Brand?>? items2,
  }) {
    final v = this as BrandList1;
    return BrandList1(
      items2 ?? v.items2,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as BrandList1;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is BrandList1 &&
            const DeepCollectionEquality().equals(other.items2, v.items2));
  }

  @override
  int get hashCode {
    final v = this as BrandList1;
    return Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(v.items2),
    );
  }

  @override
  String toString() {
    final v = this as BrandList1;
    return 'BrandList1{items: ${v.items2}}';
  }
}

mixin NamedItemList1Data<T> {
  static NamedItemList1<T> fromJson<T>(Map<String, dynamic> json, T Function(Object? v) fromJsonT) {
    return NamedItemList1<T>(
      json['name'] as String,
      (json['items'] as List<dynamic>?)?.map((e) => fromJsonT(e)).toList(),
    );
  }

  Map<String, dynamic> toJson(Object? Function(T v) toJsonT) {
    final v = this as NamedItemList1<T>;
    return <String, dynamic>{
      'name': v.name,
      'items': v.items2.map((e) => toJsonT(e)).toList(),
      'type': 'NamedItemList1',
    };
  }

  NamedItemList1<T> copyWith({
    String? name,
    List<T>? items2,
  }) {
    final v = this as NamedItemList1<T>;
    return NamedItemList1<T>(
      name ?? v.name,
      items2 ?? v.items2,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as NamedItemList1<T>;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is NamedItemList1<T> &&
            (identical(other.name, v.name) || other.name == v.name) &&
            const DeepCollectionEquality().equals(other.items2, v.items2));
  }

  @override
  int get hashCode {
    final v = this as NamedItemList1<T>;
    return Object.hash(
      runtimeType,
      v.name,
      const DeepCollectionEquality().hash(v.items2),
    );
  }

  @override
  String toString() {
    final v = this as NamedItemList1<T>;
    return 'NamedItemList1<$T>{name: ${v.name}, items: ${v.items2}}';
  }
}

mixin KeyedItemList1Data<K, T> {
  static KeyedItemList1<K, T> fromJson<K, T>(
    Map<String, dynamic> json,
    K Function(Object? v) fromJsonK,
    T Function(Object? v) fromJsonT,
  ) {
    return KeyedItemList1<K, T>(
      fromJsonK(json['key']),
      (json['items'] as List<dynamic>?)?.map((e) => fromJsonT(e)).toList(),
    );
  }

  Map<String, dynamic> toJson(Object? Function(K v) toJsonK, Object? Function(T v) toJsonT) {
    final v = this as KeyedItemList1<K, T>;
    return <String, dynamic>{
      'key': toJsonK(v.key),
      'items': v.items2.map((e) => toJsonT(e)).toList(),
      'type': 'KeyedItemList1',
    };
  }

  KeyedItemList1<K, T> copyWith({
    K? key,
    List<T>? items2,
  }) {
    final v = this as KeyedItemList1<K, T>;
    return KeyedItemList1<K, T>(
      key ?? v.key,
      items2 ?? v.items2,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as KeyedItemList1<K, T>;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is KeyedItemList1<K, T> &&
            (identical(other.key, v.key) || other.key == v.key) &&
            const DeepCollectionEquality().equals(other.items2, v.items2));
  }

  @override
  int get hashCode {
    final v = this as KeyedItemList1<K, T>;
    return Object.hash(
      runtimeType,
      v.key,
      const DeepCollectionEquality().hash(v.items2),
    );
  }

  @override
  String toString() {
    final v = this as KeyedItemList1<K, T>;
    return 'KeyedItemList1<$K,T>{key: ${v.key}, items: ${v.items2}}';
  }
}

mixin ComparableItemList2Data<T extends Comparable<T>> {
  static ComparableItemList2<T> fromJson<T extends Comparable<T>>(
    Map<String, dynamic> json,
    T Function(Object? v) fromJsonT,
  ) {
    return ComparableItemList2<T>(
      (json['items'] as List<dynamic>?)?.map((e) => fromJsonT(e)).toList(),
    );
  }

  Map<String, dynamic> toJson(Object? Function(T v) toJsonT) {
    final v = this as ComparableItemList2<T>;
    return <String, dynamic>{
      'items': v.items2.map((e) => toJsonT(e)).toList(),
      'type': 'ComparableItemList2',
    };
  }

  ComparableItemList2<T> copyWith({
    List<T>? items2,
  }) {
    final v = this as ComparableItemList2<T>;
    return ComparableItemList2<T>(
      items2 ?? v.items2,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as ComparableItemList2<T>;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ComparableItemList2<T> &&
            const DeepCollectionEquality().equals(other.items2, v.items2));
  }

  @override
  int get hashCode {
    final v = this as ComparableItemList2<T>;
    return Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(v.items2),
    );
  }

  @override
  String toString() {
    final v = this as ComparableItemList2<T>;
    return 'ComparableItemList2<$T>{items: ${v.items2}}';
  }
}

mixin ComparableItemList3Data<T1 extends Map<String, T2>, T2> {
  static ComparableItemList3<T1, T2> fromJson<T1 extends Map<String, T2>, T2>(
    Map<String, dynamic> json,
    T1 Function(Object? v) fromJsonT1,
    T2 Function(Object? v) fromJsonT2,
  ) {
    return ComparableItemList3<T1, T2>(
      (json['items'] as List<dynamic>?)?.map((e) => e as String).toList(),
    );
  }

  Map<String, dynamic> toJson(Object? Function(T1 v) toJsonT1, Object? Function(T2 v) toJsonT2) {
    final v = this as ComparableItemList3<T1, T2>;
    return <String, dynamic>{
      'items': v.items2,
      'type': 'ComparableItemList3',
    };
  }

  ComparableItemList3<T1, T2> copyWith({
    List<String>? items2,
  }) {
    final v = this as ComparableItemList3<T1, T2>;
    return ComparableItemList3<T1, T2>(
      items2 ?? v.items2,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as ComparableItemList3<T1, T2>;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ComparableItemList3<T1, T2> &&
            const DeepCollectionEquality().equals(other.items2, v.items2));
  }

  @override
  int get hashCode {
    final v = this as ComparableItemList3<T1, T2>;
    return Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(v.items2),
    );
  }

  @override
  String toString() {
    final v = this as ComparableItemList3<T1, T2>;
    return 'ComparableItemList3<$T1,T2>{items: ${v.items2}}';
  }
}
