// coverage:ignore-file
// GENERATED BY Macro: DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark
// dart format off

part of 'complex_model.dart';

mixin UserData {
  static User fromJson(Map<String, dynamic> json) {
    return User(
      id: json['id'] as String,
      name: json['name'] as String,
      age: (json['age'] as num).toInt(),
      email: json['email'] as String?,
      isActive: json['isActive'] as bool? ?? true,
      createdAt: MacroExt.decodeDateTime(json['createdAt']),
    );
  }

  Map<String, dynamic> toJson() {
    final v = this as User;
    return <String, dynamic>{
      'id': v.id,
      'name': v.name,
      'age': v.age,
      'email': ?v.email,
      'isActive': v.isActive,
      'createdAt': v.createdAt.toIso8601String(),
    };
  }

  User copyWith({
    String? id,
    String? name,
    int? age,
    String? email,
    bool? isActive,
    DateTime? createdAt,
  }) {
    final v = this as User;
    return User(
      id: id ?? v.id,
      name: name ?? v.name,
      age: age ?? v.age,
      email: email ?? v.email,
      isActive: isActive ?? v.isActive,
      createdAt: createdAt ?? v.createdAt,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as User;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is User &&
            (identical(other.id, v.id) || other.id == v.id) &&
            (identical(other.name, v.name) || other.name == v.name) &&
            (identical(other.age, v.age) || other.age == v.age) &&
            (identical(other.email, v.email) || other.email == v.email) &&
            (identical(other.isActive, v.isActive) || other.isActive == v.isActive) &&
            (identical(other.createdAt, v.createdAt) || other.createdAt == v.createdAt));
  }

  @override
  int get hashCode {
    final v = this as User;
    return Object.hash(
      runtimeType,
      v.id,
      v.name,
      v.age,
      v.email,
      v.isActive,
      v.createdAt,
    );
  }

  @override
  String toString() {
    final v = this as User;
    return 'User{id: ${v.id}, name: ${v.name}, age: ${v.age}, email: ${v.email}, isActive: ${v.isActive}, createdAt: ${v.createdAt}}';
  }
}

mixin AddressData {
  static Address fromJson(Map<String, dynamic> json) {
    return Address(
      street: json['street'] as String,
      city: json['city'] as String,
      state: json['state'] as String?,
      country: json['country'] as String,
      zipCode: json['zipCode'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final v = this as Address;
    return <String, dynamic>{
      'street': v.street,
      'city': v.city,
      'state': ?v.state,
      'country': v.country,
      'zipCode': v.zipCode,
    };
  }

  Address copyWith({
    String? street,
    String? city,
    String? state,
    String? country,
    String? zipCode,
  }) {
    final v = this as Address;
    return Address(
      street: street ?? v.street,
      city: city ?? v.city,
      state: state ?? v.state,
      country: country ?? v.country,
      zipCode: zipCode ?? v.zipCode,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as Address;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Address &&
            (identical(other.street, v.street) || other.street == v.street) &&
            (identical(other.city, v.city) || other.city == v.city) &&
            (identical(other.state, v.state) || other.state == v.state) &&
            (identical(other.country, v.country) || other.country == v.country) &&
            (identical(other.zipCode, v.zipCode) || other.zipCode == v.zipCode));
  }

  @override
  int get hashCode {
    final v = this as Address;
    return Object.hash(
      runtimeType,
      v.street,
      v.city,
      v.state,
      v.country,
      v.zipCode,
    );
  }

  @override
  String toString() {
    final v = this as Address;
    return 'Address{street: ${v.street}, city: ${v.city}, state: ${v.state}, country: ${v.country}, zipCode: ${v.zipCode}}';
  }
}

mixin PersonData {
  static Person fromJson(Map<String, dynamic> json) {
    return Person(
      name: json['name'] as String,
      age: (json['age'] as num).toInt(),
      address: AddressData.fromJson(json['address'] as Map<String, dynamic>),
      billingAddress: json['billingAddress'] == null
          ? null
          : AddressData.fromJson(json['billingAddress'] as Map<String, dynamic>),
      phoneNumbers: (json['phoneNumbers'] as List<dynamic>).map((e) => e as String).toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final v = this as Person;
    return <String, dynamic>{
      'name': v.name,
      'age': v.age,
      'address': v.address.toJson(),
      'billingAddress': ?v.billingAddress?.toJson(),
      'phoneNumbers': v.phoneNumbers,
    };
  }

  Person copyWith({
    String? name,
    int? age,
    Address? address,
    Address? billingAddress,
    List<String>? phoneNumbers,
  }) {
    final v = this as Person;
    return Person(
      name: name ?? v.name,
      age: age ?? v.age,
      address: address ?? v.address,
      billingAddress: billingAddress ?? v.billingAddress,
      phoneNumbers: phoneNumbers ?? v.phoneNumbers,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as Person;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Person &&
            (identical(other.name, v.name) || other.name == v.name) &&
            (identical(other.age, v.age) || other.age == v.age) &&
            (identical(other.address, v.address) || other.address == v.address) &&
            (identical(other.billingAddress, v.billingAddress) || other.billingAddress == v.billingAddress) &&
            const DeepCollectionEquality().equals(other.phoneNumbers, v.phoneNumbers));
  }

  @override
  int get hashCode {
    final v = this as Person;
    return Object.hash(
      runtimeType,
      v.name,
      v.age,
      v.address,
      v.billingAddress,
      const DeepCollectionEquality().hash(v.phoneNumbers),
    );
  }

  @override
  String toString() {
    final v = this as Person;
    return 'Person{name: ${v.name}, age: ${v.age}, address: ${v.address}, billingAddress: ${v.billingAddress}, phoneNumbers: ${v.phoneNumbers}}';
  }
}

mixin CartItemData {
  static CartItem fromJson(Map<String, dynamic> json) {
    return CartItem(
      productId: json['productId'] as String,
      name: json['name'] as String,
      price: (json['price'] as num).toDouble(),
      quantity: (json['quantity'] as num).toInt(),
      metadata: (json['metadata'] as Map<String, dynamic>?)?.map((k, e) => MapEntry(k, e as String)) ?? const {},
    );
  }

  Map<String, dynamic> toJson() {
    final v = this as CartItem;
    return <String, dynamic>{
      'productId': v.productId,
      'name': v.name,
      'price': v.price,
      'quantity': v.quantity,
      'metadata': v.metadata,
    };
  }

  CartItem copyWith({
    String? productId,
    String? name,
    double? price,
    int? quantity,
    Map<String, String>? metadata,
  }) {
    final v = this as CartItem;
    return CartItem(
      productId: productId ?? v.productId,
      name: name ?? v.name,
      price: price ?? v.price,
      quantity: quantity ?? v.quantity,
      metadata: metadata ?? v.metadata,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as CartItem;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CartItem &&
            (identical(other.productId, v.productId) || other.productId == v.productId) &&
            (identical(other.name, v.name) || other.name == v.name) &&
            (identical(other.price, v.price) || other.price == v.price) &&
            (identical(other.quantity, v.quantity) || other.quantity == v.quantity) &&
            const DeepCollectionEquality().equals(other.metadata, v.metadata));
  }

  @override
  int get hashCode {
    final v = this as CartItem;
    return Object.hash(
      runtimeType,
      v.productId,
      v.name,
      v.price,
      v.quantity,
      const DeepCollectionEquality().hash(v.metadata),
    );
  }

  @override
  String toString() {
    final v = this as CartItem;
    return 'CartItem{productId: ${v.productId}, name: ${v.name}, price: ${v.price}, quantity: ${v.quantity}, metadata: ${v.metadata}}';
  }
}

mixin ShoppingCartData {
  static ShoppingCart fromJson(Map<String, dynamic> json) {
    return ShoppingCart(
      userId: json['userId'] as String,
      items: (json['items'] as List<dynamic>).map((e) => CartItemData.fromJson(e as Map<String, dynamic>)).toList(),
      discounts:
          (json['discounts'] as Map<String, dynamic>?)?.map((k, e) => MapEntry(k, (e as num).toDouble())) ?? const {},
      appliedCoupons: (json['appliedCoupons'] as List<dynamic>?)?.map((e) => e as String).toSet() ?? const {},
      createdAt: MacroExt.decodeDateTime(json['createdAt']),
      lastModified: MacroExt.decodeNullableDateTime(json['lastModified']),
    );
  }

  Map<String, dynamic> toJson() {
    final v = this as ShoppingCart;
    return <String, dynamic>{
      'userId': v.userId,
      'items': v.items.map((e) => e.toJson()).toList(),
      'discounts': v.discounts,
      'appliedCoupons': v.appliedCoupons.map((e) => e).toList(),
      'createdAt': v.createdAt.toIso8601String(),
      'lastModified': ?v.lastModified?.toIso8601String(),
    };
  }

  ShoppingCart copyWith({
    String? userId,
    List<CartItem>? items,
    Map<String, double>? discounts,
    Set<String>? appliedCoupons,
    DateTime? createdAt,
    DateTime? lastModified,
  }) {
    final v = this as ShoppingCart;
    return ShoppingCart(
      userId: userId ?? v.userId,
      items: items ?? v.items,
      discounts: discounts ?? v.discounts,
      appliedCoupons: appliedCoupons ?? v.appliedCoupons,
      createdAt: createdAt ?? v.createdAt,
      lastModified: lastModified ?? v.lastModified,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as ShoppingCart;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ShoppingCart &&
            (identical(other.userId, v.userId) || other.userId == v.userId) &&
            const DeepCollectionEquality().equals(other.items, v.items) &&
            const DeepCollectionEquality().equals(other.discounts, v.discounts) &&
            const DeepCollectionEquality().equals(other.appliedCoupons, v.appliedCoupons) &&
            (identical(other.createdAt, v.createdAt) || other.createdAt == v.createdAt) &&
            (identical(other.lastModified, v.lastModified) || other.lastModified == v.lastModified));
  }

  @override
  int get hashCode {
    final v = this as ShoppingCart;
    return Object.hash(
      runtimeType,
      v.userId,
      const DeepCollectionEquality().hash(v.items),
      const DeepCollectionEquality().hash(v.discounts),
      const DeepCollectionEquality().hash(v.appliedCoupons),
      v.createdAt,
      v.lastModified,
    );
  }

  @override
  String toString() {
    final v = this as ShoppingCart;
    return 'ShoppingCart{userId: ${v.userId}, items: ${v.items}, discounts: ${v.discounts}, appliedCoupons: ${v.appliedCoupons}, createdAt: ${v.createdAt}, lastModified: ${v.lastModified}}';
  }
}

mixin AccountData {
  static Account fromJson(Map<String, dynamic> json) {
    return Account(
      id: json['id'] as String,
      username: json['username'] as String,
      role: MacroExt.decodeNullableEnum(UserRole.values, json['role'], unknownValue: null) ?? UserRole.user,
      status:
          MacroExt.decodeNullableEnum(AccountStatus.values, json['status'], unknownValue: null) ??
          AccountStatus.pending,
      previousRoles:
          (json['previousRoles'] as List<dynamic>?)
              ?.map((e) => MacroExt.decodeEnum(UserRole.values, e, unknownValue: null))
              .toList() ??
          const [],
      permissions: json['permissions'] as Map<String, dynamic>? ?? const {},
    );
  }

  Map<String, dynamic> toJson() {
    final v = this as Account;
    return <String, dynamic>{
      'id': v.id,
      'username': v.username,
      'role': v.role.name,
      'status': v.status.name,
      'previousRoles': v.previousRoles.map((e) => e.name).toList(),
      'permissions': v.permissions,
    };
  }

  Account copyWith({
    String? id,
    String? username,
    UserRole? role,
    AccountStatus? status,
    List<UserRole>? previousRoles,
    Map<String, dynamic>? permissions,
  }) {
    final v = this as Account;
    return Account(
      id: id ?? v.id,
      username: username ?? v.username,
      role: role ?? v.role,
      status: status ?? v.status,
      previousRoles: previousRoles ?? v.previousRoles,
      permissions: permissions ?? v.permissions,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as Account;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Account &&
            (identical(other.id, v.id) || other.id == v.id) &&
            (identical(other.username, v.username) || other.username == v.username) &&
            (identical(other.role, v.role) || other.role == v.role) &&
            (identical(other.status, v.status) || other.status == v.status) &&
            const DeepCollectionEquality().equals(other.previousRoles, v.previousRoles) &&
            const DeepCollectionEquality().equals(other.permissions, v.permissions));
  }

  @override
  int get hashCode {
    final v = this as Account;
    return Object.hash(
      runtimeType,
      v.id,
      v.username,
      v.role,
      v.status,
      const DeepCollectionEquality().hash(v.previousRoles),
      const DeepCollectionEquality().hash(v.permissions),
    );
  }

  @override
  String toString() {
    final v = this as Account;
    return 'Account{id: ${v.id}, username: ${v.username}, role: ${v.role}, status: ${v.status}, previousRoles: ${v.previousRoles}, permissions: ${v.permissions}}';
  }
}

mixin ResultData<T> {
  static Result<T> fromJson<T>(Map<String, dynamic> json, T Function(Object? v) fromJsonT) {
    return Result<T>(
      data: MacroExt.decodeNullableGeneric(json['data'], fromJsonT),
      error: json['error'] as String?,
      isSuccess: json['isSuccess'] as bool,
      timestamp: MacroExt.decodeNullableDateTime(json['timestamp']),
    );
  }

  Map<String, dynamic> toJson(Object? Function(T v) toJsonT) {
    final v = this as Result<T>;
    return <String, dynamic>{
      'data': ?MacroExt.encodeNullableGeneric(v.data, toJsonT),
      'error': ?v.error,
      'isSuccess': v.isSuccess,
      'timestamp': ?v.timestamp?.toIso8601String(),
    };
  }

  Result<T> copyWith({
    T? data,
    String? error,
    bool? isSuccess,
    DateTime? timestamp,
  }) {
    final v = this as Result<T>;
    return Result<T>(
      data: data ?? v.data,
      error: error ?? v.error,
      isSuccess: isSuccess ?? v.isSuccess,
      timestamp: timestamp ?? v.timestamp,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as Result<T>;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Result<T> &&
            (identical(other.data, v.data) || other.data == v.data) &&
            (identical(other.error, v.error) || other.error == v.error) &&
            (identical(other.isSuccess, v.isSuccess) || other.isSuccess == v.isSuccess) &&
            (identical(other.timestamp, v.timestamp) || other.timestamp == v.timestamp));
  }

  @override
  int get hashCode {
    final v = this as Result<T>;
    return Object.hash(
      runtimeType,
      v.data,
      v.error,
      v.isSuccess,
      v.timestamp,
    );
  }

  @override
  String toString() {
    final v = this as Result<T>;
    return 'Result<$T>{data: ${v.data}, error: ${v.error}, isSuccess: ${v.isSuccess}, timestamp: ${v.timestamp}}';
  }
}

mixin PaymentData {
  static Payment fromJson(Map<String, dynamic> json) {
    return Payment(
      id: json['id'] as String,
      amount: (json['amount'] as num).toDouble(),
      currency: json['currency'] as String,
      method: json['method'] as String,
      processedAt: MacroExt.decodeDateTime(json['processedAt']),
      metadata: (json['metadata'] as Map<String, dynamic>?)?.map((k, e) => MapEntry(k, e as String)) ?? const {},
    );
  }

  Map<String, dynamic> toJson() {
    final v = this as Payment;
    return <String, dynamic>{
      'id': v.id,
      'amount': v.amount,
      'currency': v.currency,
      'method': v.method,
      'processedAt': v.processedAt.toIso8601String(),
      'metadata': v.metadata,
    };
  }

  Payment copyWith({
    String? id,
    double? amount,
    String? currency,
    String? method,
    DateTime? processedAt,
    Map<String, String>? metadata,
  }) {
    final v = this as Payment;
    return Payment(
      id: id ?? v.id,
      amount: amount ?? v.amount,
      currency: currency ?? v.currency,
      method: method ?? v.method,
      processedAt: processedAt ?? v.processedAt,
      metadata: metadata ?? v.metadata,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as Payment;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Payment &&
            (identical(other.id, v.id) || other.id == v.id) &&
            (identical(other.amount, v.amount) || other.amount == v.amount) &&
            (identical(other.currency, v.currency) || other.currency == v.currency) &&
            (identical(other.method, v.method) || other.method == v.method) &&
            (identical(other.processedAt, v.processedAt) || other.processedAt == v.processedAt) &&
            const DeepCollectionEquality().equals(other.metadata, v.metadata));
  }

  @override
  int get hashCode {
    final v = this as Payment;
    return Object.hash(
      runtimeType,
      v.id,
      v.amount,
      v.currency,
      v.method,
      v.processedAt,
      const DeepCollectionEquality().hash(v.metadata),
    );
  }

  @override
  String toString() {
    final v = this as Payment;
    return 'Payment{id: ${v.id}, amount: ${v.amount}, currency: ${v.currency}, method: ${v.method}, processedAt: ${v.processedAt}, metadata: ${v.metadata}}';
  }
}

mixin ExpenseData {
  static Expense fromJson(Map<String, dynamic> json) {
    return Expense(
      id: json['id'] as String,
      description: json['description'] as String,
      amount: (json['amount'] as num).toDouble(),
      category: json['category'] as String,
      date: MacroExt.decodeDateTime(json['date']),
      approvedBy: PersonData.fromJson(json['approvedBy'] as Map<String, dynamic>),
    );
  }

  Map<String, dynamic> toJson() {
    final v = this as Expense;
    return <String, dynamic>{
      'id': v.id,
      'description': v.description,
      'amount': v.amount,
      'category': v.category,
      'date': v.date.toIso8601String(),
      'approvedBy': v.approvedBy.toJson(),
    };
  }

  Expense copyWith({
    String? id,
    String? description,
    double? amount,
    String? category,
    DateTime? date,
    Person? approvedBy,
  }) {
    final v = this as Expense;
    return Expense(
      id: id ?? v.id,
      description: description ?? v.description,
      amount: amount ?? v.amount,
      category: category ?? v.category,
      date: date ?? v.date,
      approvedBy: approvedBy ?? v.approvedBy,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as Expense;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Expense &&
            (identical(other.id, v.id) || other.id == v.id) &&
            (identical(other.description, v.description) || other.description == v.description) &&
            (identical(other.amount, v.amount) || other.amount == v.amount) &&
            (identical(other.category, v.category) || other.category == v.category) &&
            (identical(other.date, v.date) || other.date == v.date) &&
            (identical(other.approvedBy, v.approvedBy) || other.approvedBy == v.approvedBy));
  }

  @override
  int get hashCode {
    final v = this as Expense;
    return Object.hash(
      runtimeType,
      v.id,
      v.description,
      v.amount,
      v.category,
      v.date,
      v.approvedBy,
    );
  }

  @override
  String toString() {
    final v = this as Expense;
    return 'Expense{id: ${v.id}, description: ${v.description}, amount: ${v.amount}, category: ${v.category}, date: ${v.date}, approvedBy: ${v.approvedBy}}';
  }
}

mixin BudgetData {
  static Budget fromJson(Map<String, dynamic> json) {
    return Budget(
      allocated: (json['allocated'] as num).toDouble(),
      spent: (json['spent'] as num).toDouble(),
      currency: json['currency'] as String? ?? 'USD',
      fiscalYearStart: MacroExt.decodeDateTime(json['fiscalYearStart']),
      fiscalYearEnd: MacroExt.decodeDateTime(json['fiscalYearEnd']),
      expenses:
          (json['expenses'] as List<dynamic>?)?.map((e) => ExpenseData.fromJson(e as Map<String, dynamic>)).toList() ??
          const [],
    );
  }

  Map<String, dynamic> toJson() {
    final v = this as Budget;
    return <String, dynamic>{
      'allocated': v.allocated,
      'spent': v.spent,
      'currency': v.currency,
      'fiscalYearStart': v.fiscalYearStart.toIso8601String(),
      'fiscalYearEnd': v.fiscalYearEnd.toIso8601String(),
      'expenses': v.expenses.map((e) => e.toJson()).toList(),
    };
  }

  Budget copyWith({
    double? allocated,
    double? spent,
    String? currency,
    DateTime? fiscalYearStart,
    DateTime? fiscalYearEnd,
    List<Expense>? expenses,
  }) {
    final v = this as Budget;
    return Budget(
      allocated: allocated ?? v.allocated,
      spent: spent ?? v.spent,
      currency: currency ?? v.currency,
      fiscalYearStart: fiscalYearStart ?? v.fiscalYearStart,
      fiscalYearEnd: fiscalYearEnd ?? v.fiscalYearEnd,
      expenses: expenses ?? v.expenses,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as Budget;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Budget &&
            (identical(other.allocated, v.allocated) || other.allocated == v.allocated) &&
            (identical(other.spent, v.spent) || other.spent == v.spent) &&
            (identical(other.currency, v.currency) || other.currency == v.currency) &&
            (identical(other.fiscalYearStart, v.fiscalYearStart) || other.fiscalYearStart == v.fiscalYearStart) &&
            (identical(other.fiscalYearEnd, v.fiscalYearEnd) || other.fiscalYearEnd == v.fiscalYearEnd) &&
            const DeepCollectionEquality().equals(other.expenses, v.expenses));
  }

  @override
  int get hashCode {
    final v = this as Budget;
    return Object.hash(
      runtimeType,
      v.allocated,
      v.spent,
      v.currency,
      v.fiscalYearStart,
      v.fiscalYearEnd,
      const DeepCollectionEquality().hash(v.expenses),
    );
  }

  @override
  String toString() {
    final v = this as Budget;
    return 'Budget{allocated: ${v.allocated}, spent: ${v.spent}, currency: ${v.currency}, fiscalYearStart: ${v.fiscalYearStart}, fiscalYearEnd: ${v.fiscalYearEnd}, expenses: ${v.expenses}}';
  }
}

mixin DepartmentData {
  static Department fromJson(Map<String, dynamic> json) {
    return Department(
      id: json['id'] as String,
      name: json['name'] as String,
      manager: PersonData.fromJson(json['manager'] as Map<String, dynamic>),
      members: (json['members'] as List<dynamic>).map((e) => PersonData.fromJson(e as Map<String, dynamic>)).toList(),
      budget: BudgetData.fromJson(json['budget'] as Map<String, dynamic>),
    );
  }

  Map<String, dynamic> toJson() {
    final v = this as Department;
    return <String, dynamic>{
      'id': v.id,
      'name': v.name,
      'manager': v.manager.toJson(),
      'members': v.members.map((e) => e.toJson()).toList(),
      'budget': v.budget.toJson(),
    };
  }

  Department copyWith({
    String? id,
    String? name,
    Person? manager,
    List<Person>? members,
    Budget? budget,
  }) {
    final v = this as Department;
    return Department(
      id: id ?? v.id,
      name: name ?? v.name,
      manager: manager ?? v.manager,
      members: members ?? v.members,
      budget: budget ?? v.budget,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as Department;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Department &&
            (identical(other.id, v.id) || other.id == v.id) &&
            (identical(other.name, v.name) || other.name == v.name) &&
            (identical(other.manager, v.manager) || other.manager == v.manager) &&
            const DeepCollectionEquality().equals(other.members, v.members) &&
            (identical(other.budget, v.budget) || other.budget == v.budget));
  }

  @override
  int get hashCode {
    final v = this as Department;
    return Object.hash(
      runtimeType,
      v.id,
      v.name,
      v.manager,
      const DeepCollectionEquality().hash(v.members),
      v.budget,
    );
  }

  @override
  String toString() {
    final v = this as Department;
    return 'Department{id: ${v.id}, name: ${v.name}, manager: ${v.manager}, members: ${v.members}, budget: ${v.budget}}';
  }
}

mixin SettingsData {
  static Settings fromJson(Map<String, dynamic> json) {
    return Settings(
      notificationsEnabled: json['notificationsEnabled'] as bool? ?? true,
      theme: json['theme'] as String? ?? 'light',
      features: (json['features'] as Map<String, dynamic>?)?.map((k, e) => MapEntry(k, e as bool)) ?? const {},
      allowedDomains: (json['allowedDomains'] as List<dynamic>?)?.map((e) => e as String).toList() ?? const [],
    );
  }

  Map<String, dynamic> toJson() {
    final v = this as Settings;
    return <String, dynamic>{
      'notificationsEnabled': v.notificationsEnabled,
      'theme': v.theme,
      'features': v.features,
      'allowedDomains': v.allowedDomains,
    };
  }

  Settings copyWith({
    bool? notificationsEnabled,
    String? theme,
    Map<String, bool>? features,
    List<String>? allowedDomains,
  }) {
    final v = this as Settings;
    return Settings(
      notificationsEnabled: notificationsEnabled ?? v.notificationsEnabled,
      theme: theme ?? v.theme,
      features: features ?? v.features,
      allowedDomains: allowedDomains ?? v.allowedDomains,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as Settings;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Settings &&
            (identical(other.notificationsEnabled, v.notificationsEnabled) ||
                other.notificationsEnabled == v.notificationsEnabled) &&
            (identical(other.theme, v.theme) || other.theme == v.theme) &&
            const DeepCollectionEquality().equals(other.features, v.features) &&
            const DeepCollectionEquality().equals(other.allowedDomains, v.allowedDomains));
  }

  @override
  int get hashCode {
    final v = this as Settings;
    return Object.hash(
      runtimeType,
      v.notificationsEnabled,
      v.theme,
      const DeepCollectionEquality().hash(v.features),
      const DeepCollectionEquality().hash(v.allowedDomains),
    );
  }

  @override
  String toString() {
    final v = this as Settings;
    return 'Settings{notificationsEnabled: ${v.notificationsEnabled}, theme: ${v.theme}, features: ${v.features}, allowedDomains: ${v.allowedDomains}}';
  }
}

mixin OrganizationData {
  static Organization fromJson(Map<String, dynamic> json) {
    return Organization(
      id: json['id'] as String,
      name: json['name'] as String,
      headquarters: AddressData.fromJson(json['headquarters'] as Map<String, dynamic>),
      departments: (json['departments'] as List<dynamic>)
          .map((e) => DepartmentData.fromJson(e as Map<String, dynamic>))
          .toList(),
      employees: (json['employees'] as Map<String, dynamic>).map(
        (k, e) => MapEntry(k, PersonData.fromJson(e as Map<String, dynamic>)),
      ),
      settings: SettingsData.fromJson(json['settings'] as Map<String, dynamic>),
    );
  }

  Map<String, dynamic> toJson() {
    final v = this as Organization;
    return <String, dynamic>{
      'id': v.id,
      'name': v.name,
      'headquarters': v.headquarters.toJson(),
      'departments': v.departments.map((e) => e.toJson()).toList(),
      'employees': v.employees.map((k, e) => MapEntry(k, e.toJson())),
      'settings': v.settings.toJson(),
    };
  }

  Organization copyWith({
    String? id,
    String? name,
    Address? headquarters,
    List<Department>? departments,
    Map<String, Person>? employees,
    Settings? settings,
  }) {
    final v = this as Organization;
    return Organization(
      id: id ?? v.id,
      name: name ?? v.name,
      headquarters: headquarters ?? v.headquarters,
      departments: departments ?? v.departments,
      employees: employees ?? v.employees,
      settings: settings ?? v.settings,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as Organization;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Organization &&
            (identical(other.id, v.id) || other.id == v.id) &&
            (identical(other.name, v.name) || other.name == v.name) &&
            (identical(other.headquarters, v.headquarters) || other.headquarters == v.headquarters) &&
            const DeepCollectionEquality().equals(other.departments, v.departments) &&
            const DeepCollectionEquality().equals(other.employees, v.employees) &&
            (identical(other.settings, v.settings) || other.settings == v.settings));
  }

  @override
  int get hashCode {
    final v = this as Organization;
    return Object.hash(
      runtimeType,
      v.id,
      v.name,
      v.headquarters,
      const DeepCollectionEquality().hash(v.departments),
      const DeepCollectionEquality().hash(v.employees),
      v.settings,
    );
  }

  @override
  String toString() {
    final v = this as Organization;
    return 'Organization{id: ${v.id}, name: ${v.name}, headquarters: ${v.headquarters}, departments: ${v.departments}, employees: ${v.employees}, settings: ${v.settings}}';
  }
}

mixin ConfigurationData {
  static Configuration fromJson(Map<String, dynamic> json) {
    return Configuration(
      appName: json['appName'] as String? ?? 'MyApp',
      maxRetries: (json['maxRetries'] as num?)?.toInt() ?? 3,
      timeout: json['timeout'] == null
          ? const Duration(seconds: 30)
          : Duration(microseconds: (json['timeout'] as num).toInt()),
      headers:
          (json['headers'] as Map<String, dynamic>?)?.map((k, e) => MapEntry(k, e as String)) ??
          const {'Content-Type': 'application/json', 'Accept': 'application/json'},
      endpoints:
          (json['endpoints'] as List<dynamic>?)?.map((e) => e as String).toList() ?? const ['https://api.example.com'],
      debugMode: json['debugMode'] as bool? ?? false,
    );
  }

  Map<String, dynamic> toJson() {
    final v = this as Configuration;
    return <String, dynamic>{
      'appName': v.appName,
      'maxRetries': v.maxRetries,
      'timeout': v.timeout.inMicroseconds,
      'headers': v.headers,
      'endpoints': v.endpoints,
      'debugMode': v.debugMode,
    };
  }

  Configuration copyWith({
    String? appName,
    int? maxRetries,
    Duration? timeout,
    Map<String, String>? headers,
    List<String>? endpoints,
    bool? debugMode,
  }) {
    final v = this as Configuration;
    return Configuration(
      appName: appName ?? v.appName,
      maxRetries: maxRetries ?? v.maxRetries,
      timeout: timeout ?? v.timeout,
      headers: headers ?? v.headers,
      endpoints: endpoints ?? v.endpoints,
      debugMode: debugMode ?? v.debugMode,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as Configuration;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Configuration &&
            (identical(other.appName, v.appName) || other.appName == v.appName) &&
            (identical(other.maxRetries, v.maxRetries) || other.maxRetries == v.maxRetries) &&
            (identical(other.timeout, v.timeout) || other.timeout == v.timeout) &&
            const DeepCollectionEquality().equals(other.headers, v.headers) &&
            const DeepCollectionEquality().equals(other.endpoints, v.endpoints) &&
            (identical(other.debugMode, v.debugMode) || other.debugMode == v.debugMode));
  }

  @override
  int get hashCode {
    final v = this as Configuration;
    return Object.hash(
      runtimeType,
      v.appName,
      v.maxRetries,
      v.timeout,
      const DeepCollectionEquality().hash(v.headers),
      const DeepCollectionEquality().hash(v.endpoints),
      v.debugMode,
    );
  }

  @override
  String toString() {
    final v = this as Configuration;
    return 'Configuration{appName: ${v.appName}, maxRetries: ${v.maxRetries}, timeout: ${v.timeout}, headers: ${v.headers}, endpoints: ${v.endpoints}, debugMode: ${v.debugMode}}';
  }
}

mixin SecureDataData {
  static SecureData fromJson(Map<String, dynamic> json) {
    return SecureData(
      publicId: json['publicId'] as String,
      privateKey: json['privateKey'] as String,
      createdAt: MacroExt.decodeDateTime(json['createdAt']),
    );
  }

  Map<String, dynamic> toJson() {
    final v = this as SecureData;
    return <String, dynamic>{
      'publicId': v.publicId,
      'privateKey': v._privateKey,
      'createdAt': v._createdAt.toIso8601String(),
    };
  }

  SecureData copyWith({
    String? publicId,
    String? privateKey,
    DateTime? createdAt,
  }) {
    final v = this as SecureData;
    return SecureData(
      publicId: publicId ?? v.publicId,
      privateKey: privateKey ?? v._privateKey,
      createdAt: createdAt ?? v._createdAt,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as SecureData;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is SecureData &&
            (identical(other.publicId, v.publicId) || other.publicId == v.publicId) &&
            (identical(other._privateKey, v._privateKey) || other._privateKey == v._privateKey) &&
            (identical(other._createdAt, v._createdAt) || other._createdAt == v._createdAt));
  }

  @override
  int get hashCode {
    final v = this as SecureData;
    return Object.hash(
      runtimeType,
      v.publicId,
      v._privateKey,
      v._createdAt,
    );
  }

  @override
  String toString() {
    final v = this as SecureData;
    return 'SecureData{publicId: ${v.publicId}, privateKey: ${v._privateKey}, createdAt: ${v._createdAt}}';
  }
}

mixin ApiResponseData<T> {
  static ApiResponse<T> fromJson<T>(Map<String, dynamic> json, T Function(Object? v) fromJsonT) {
    return ApiResponse<T>(
      statusCode: (json['statusCode'] as num).toInt(),
      data: fromJsonT(json['data']),
      message: json['message'] as String?,
      headers: (json['headers'] as Map<String, dynamic>?)?.map((k, e) => MapEntry(k, e as String)) ?? const {},
    );
  }

  Map<String, dynamic> toJson(Object? Function(T v) toJsonT) {
    final v = this as ApiResponse<T>;
    return <String, dynamic>{
      'statusCode': v.statusCode,
      'data': toJsonT(v.data),
      'message': ?v.message,
      'headers': v.headers,
    };
  }

  ApiResponse<T> copyWith({
    int? statusCode,
    T? data,
    String? message,
    Map<String, String>? headers,
  }) {
    final v = this as ApiResponse<T>;
    return ApiResponse<T>(
      statusCode: statusCode ?? v.statusCode,
      data: data ?? v.data,
      message: message ?? v.message,
      headers: headers ?? v.headers,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as ApiResponse<T>;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ApiResponse<T> &&
            (identical(other.statusCode, v.statusCode) || other.statusCode == v.statusCode) &&
            (identical(other.data, v.data) || other.data == v.data) &&
            (identical(other.message, v.message) || other.message == v.message) &&
            const DeepCollectionEquality().equals(other.headers, v.headers));
  }

  @override
  int get hashCode {
    final v = this as ApiResponse<T>;
    return Object.hash(
      runtimeType,
      v.statusCode,
      v.data,
      v.message,
      const DeepCollectionEquality().hash(v.headers),
    );
  }

  @override
  String toString() {
    final v = this as ApiResponse<T>;
    return 'ApiResponse<$T>{statusCode: ${v.statusCode}, data: ${v.data}, message: ${v.message}, headers: ${v.headers}}';
  }
}

mixin OrderNoteData {
  static OrderNote fromJson(Map<String, dynamic> json) {
    return OrderNote(
      id: json['id'] as String,
      content: json['content'] as String,
      author: PersonData.fromJson(json['author'] as Map<String, dynamic>),
      createdAt: MacroExt.decodeDateTime(json['createdAt']),
      isInternal: json['isInternal'] as bool? ?? false,
    );
  }

  Map<String, dynamic> toJson() {
    final v = this as OrderNote;
    return <String, dynamic>{
      'id': v.id,
      'content': v.content,
      'author': v.author.toJson(),
      'createdAt': v.createdAt.toIso8601String(),
      'isInternal': v.isInternal,
    };
  }

  OrderNote copyWith({
    String? id,
    String? content,
    Person? author,
    DateTime? createdAt,
    bool? isInternal,
  }) {
    final v = this as OrderNote;
    return OrderNote(
      id: id ?? v.id,
      content: content ?? v.content,
      author: author ?? v.author,
      createdAt: createdAt ?? v.createdAt,
      isInternal: isInternal ?? v.isInternal,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as OrderNote;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is OrderNote &&
            (identical(other.id, v.id) || other.id == v.id) &&
            (identical(other.content, v.content) || other.content == v.content) &&
            (identical(other.author, v.author) || other.author == v.author) &&
            (identical(other.createdAt, v.createdAt) || other.createdAt == v.createdAt) &&
            (identical(other.isInternal, v.isInternal) || other.isInternal == v.isInternal));
  }

  @override
  int get hashCode {
    final v = this as OrderNote;
    return Object.hash(
      runtimeType,
      v.id,
      v.content,
      v.author,
      v.createdAt,
      v.isInternal,
    );
  }

  @override
  String toString() {
    final v = this as OrderNote;
    return 'OrderNote{id: ${v.id}, content: ${v.content}, author: ${v.author}, createdAt: ${v.createdAt}, isInternal: ${v.isInternal}}';
  }
}

mixin OrderSystemData {
  static OrderSystem fromJson(Map<String, dynamic> json) {
    return OrderSystem(
      orderId: json['orderId'] as String,
      customer: PersonData.fromJson(json['customer'] as Map<String, dynamic>),
      shippingAddress: AddressData.fromJson(json['shippingAddress'] as Map<String, dynamic>),
      billingAddress: json['billingAddress'] == null
          ? null
          : AddressData.fromJson(json['billingAddress'] as Map<String, dynamic>),
      cart: ShoppingCartData.fromJson(json['cart'] as Map<String, dynamic>),
      payments: (json['payments'] as List<dynamic>)
          .map((e) => PaymentData.fromJson(e as Map<String, dynamic>))
          .toList(),
      status:
          MacroExt.decodeNullableEnum(OrderStatus.values, json['status'], unknownValue: null) ?? OrderStatus.pending,
      statusHistory: (json['statusHistory'] as Map<String, dynamic>).map(
        (k, e) => MapEntry(MacroExt.decodeEnum(OrderStatus.values, k, unknownValue: null), MacroExt.decodeDateTime(e)),
      ),
      tags: (json['tags'] as List<dynamic>?)?.map((e) => e as String).toSet() ?? const {},
      notes:
          (json['notes'] as List<dynamic>?)?.map((e) => OrderNoteData.fromJson(e as Map<String, dynamic>)).toList() ??
          const [],
      config: ConfigurationData.fromJson(json['config'] as Map<String, dynamic>),
    );
  }

  Map<String, dynamic> toJson() {
    final v = this as OrderSystem;
    return <String, dynamic>{
      'orderId': v.orderId,
      'customer': v.customer.toJson(),
      'shippingAddress': v.shippingAddress.toJson(),
      'billingAddress': ?v.billingAddress?.toJson(),
      'cart': v.cart.toJson(),
      'payments': v.payments.map((e) => e.toJson()).toList(),
      'status': v.status.name,
      'statusHistory': v.statusHistory.map((k, e) => MapEntry(k.name, e.toIso8601String())),
      'tags': v.tags.map((e) => e).toList(),
      'notes': v.notes.map((e) => e.toJson()).toList(),
      'config': v.config.toJson(),
    };
  }

  OrderSystem copyWith({
    String? orderId,
    Person? customer,
    Address? shippingAddress,
    Address? billingAddress,
    ShoppingCart? cart,
    List<Payment>? payments,
    OrderStatus? status,
    Map<OrderStatus, DateTime>? statusHistory,
    Set<String>? tags,
    List<OrderNote>? notes,
    Configuration? config,
  }) {
    final v = this as OrderSystem;
    return OrderSystem(
      orderId: orderId ?? v.orderId,
      customer: customer ?? v.customer,
      shippingAddress: shippingAddress ?? v.shippingAddress,
      billingAddress: billingAddress ?? v.billingAddress,
      cart: cart ?? v.cart,
      payments: payments ?? v.payments,
      status: status ?? v.status,
      statusHistory: statusHistory ?? v.statusHistory,
      tags: tags ?? v.tags,
      notes: notes ?? v.notes,
      config: config ?? v.config,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as OrderSystem;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is OrderSystem &&
            (identical(other.orderId, v.orderId) || other.orderId == v.orderId) &&
            (identical(other.customer, v.customer) || other.customer == v.customer) &&
            (identical(other.shippingAddress, v.shippingAddress) || other.shippingAddress == v.shippingAddress) &&
            (identical(other.billingAddress, v.billingAddress) || other.billingAddress == v.billingAddress) &&
            (identical(other.cart, v.cart) || other.cart == v.cart) &&
            const DeepCollectionEquality().equals(other.payments, v.payments) &&
            (identical(other.status, v.status) || other.status == v.status) &&
            const DeepCollectionEquality().equals(other.statusHistory, v.statusHistory) &&
            const DeepCollectionEquality().equals(other.tags, v.tags) &&
            const DeepCollectionEquality().equals(other.notes, v.notes) &&
            (identical(other.config, v.config) || other.config == v.config));
  }

  @override
  int get hashCode {
    final v = this as OrderSystem;
    return Object.hash(
      runtimeType,
      v.orderId,
      v.customer,
      v.shippingAddress,
      v.billingAddress,
      v.cart,
      const DeepCollectionEquality().hash(v.payments),
      v.status,
      const DeepCollectionEquality().hash(v.statusHistory),
      const DeepCollectionEquality().hash(v.tags),
      const DeepCollectionEquality().hash(v.notes),
      v.config,
    );
  }

  @override
  String toString() {
    final v = this as OrderSystem;
    return 'OrderSystem{orderId: ${v.orderId}, customer: ${v.customer}, shippingAddress: ${v.shippingAddress}, billingAddress: ${v.billingAddress}, cart: ${v.cart}, payments: ${v.payments}, status: ${v.status}, statusHistory: ${v.statusHistory}, tags: ${v.tags}, notes: ${v.notes}, config: ${v.config}}';
  }
}
