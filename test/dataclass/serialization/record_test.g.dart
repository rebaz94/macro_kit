// coverage:ignore-file
// GENERATED BY Macro: DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, unused_local_variable, unnecessary_overrides, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark
// dart format off

part of 'record_test.dart';

mixin TupleModelData {
  static TupleModel fromJson(Map<String, dynamic> json) {
    return TupleModel(
      value1: (
        json['value1']['\$1'] as String,
        (json['value1']['\$2'] as num).toInt(),
      ),
      value2: (
        json['value2']['\$1'] as String,
        (json['value2']['\$2'] as num).toInt(),
        flag: json['value2']['flag'] as bool,
        name: json['value2']['name'] as String?,
      ),
      value3: (
        json['value3']['\$1'] as String,
        year: (json['value3']['current_year'] as num).toInt(),
      ),
      value4: (
        json['value4']['\$1'] as String,
        active: json['value4']['is_active'] as bool,
        year: (json['value4']['current_year'] as num).toInt(),
      ),
      value5: (
        json['value5']['\$1'] as String,
        active: json['value5']['active'] as bool,
        year: json['value5']['year'] as String,
      ),
      value6: (
        json['value6']['\$1'] as String,
        active: json['value6']['active'] as bool,
        year: (json['value6']['year'] as num).toInt(),
      ),
      value7: json['value7'] == null
          ? null
          : (
              json['value7']['\$1'] as String,
              (json['value7']['\$2'] as num).toInt(),
            ),
      value8: (
        json['value8']['\$1'] as String,
        active: json['value8']['is_active'] as bool,
        year: json['value8']['current_year'] as String,
      ),
    );
  }

  Map<String, dynamic> toJson() {
    final v = this as TupleModel;
    return <String, dynamic>{
      'value1': <String, dynamic>{
        '\$1': v.value1.$1,
        '\$2': v.value1.$2,
      },
      'value2': <String, dynamic>{
        '\$1': v.value2.$1,
        '\$2': v.value2.$2,
        'flag': v.value2.flag,
        'name': ?v.value2.name,
      },
      'value3': <String, dynamic>{
        '\$1': v.value3.$1,
        'current_year': v.value3.year,
      },
      'value4': <String, dynamic>{
        '\$1': v.value4.$1,
        'is_active': v.value4.active,
        'current_year': v.value4.year,
      },
      'value5': <String, dynamic>{
        '\$1': v.value5.$1,
        'active': v.value5.active,
        'year': v.value5.year,
      },
      'value6': <String, dynamic>{
        '\$1': v.value6.$1,
        'active': v.value6.active,
        'year': v.value6.year,
      },
      'value7': ?(v.value7 == null
          ? null
          : <String, dynamic>{
              '\$1': v.value7!.$1,
              '\$2': v.value7!.$2,
            }),
      'value8': <String, dynamic>{
        '\$1': v.value8.$1,
        'is_active': v.value8.active,
        'current_year': v.value8.year,
      },
    };
  }

  TupleModel copyWith({
    (String, int)? value1,
    (String, int, {bool flag, String? name})? value2,
    TypeDefTuple? value3,
    TypeDefTupleGen<int>? value4,
    (String, {bool active, String year})? value5,
    (String, {bool active, int year})? value6,
    (String, int)? value7,
    TypeDefTupleGen<String>? value8,
  }) {
    final v = this as TupleModel;
    return TupleModel(
      value1: value1 ?? v.value1,
      value2: value2 ?? v.value2,
      value3: value3 ?? v.value3,
      value4: value4 ?? v.value4,
      value5: value5 ?? v.value5,
      value6: value6 ?? v.value6,
      value7: value7 ?? v.value7,
      value8: value8 ?? v.value8,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as TupleModel;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is TupleModel &&
            (identical(other.value1, v.value1) || other.value1 == v.value1) &&
            (identical(other.value2, v.value2) || other.value2 == v.value2) &&
            (identical(other.value3, v.value3) || other.value3 == v.value3) &&
            (identical(other.value4, v.value4) || other.value4 == v.value4) &&
            (identical(other.value5, v.value5) || other.value5 == v.value5) &&
            (identical(other.value6, v.value6) || other.value6 == v.value6) &&
            (identical(other.value7, v.value7) || other.value7 == v.value7) &&
            (identical(other.value8, v.value8) || other.value8 == v.value8));
  }

  @override
  int get hashCode {
    final v = this as TupleModel;
    return Object.hash(
      runtimeType,
      v.value1,
      v.value2,
      v.value3,
      v.value4,
      v.value5,
      v.value6,
      v.value7,
      v.value8,
    );
  }

  @override
  String toString() {
    final v = this as TupleModel;
    return 'TupleModel{value1: ${v.value1}, value2: ${v.value2}, value3: ${v.value3}, value4: ${v.value4}, value5: ${v.value5}, value6: ${v.value6}, value7: ${v.value7}, value8: ${v.value8}}';
  }
}

mixin TupleModel2Data<T> {
  static TupleModel2<T> fromJson<T>(Map<String, dynamic> json, T Function(Object? v) fromJsonT) {
    return TupleModel2<T>(
      value1: (
        json['value1']['\$1'] as String,
        fromJsonT(json['value1']['\$2']),
      ),
      value2: (
        json['value2']['\$1'] as String,
        fromJsonT(json['value2']['\$2']),
        flag: json['value2']['flag'] as bool,
        name: json['value2']['name'] as String?,
      ),
      value3: (
        json['value3']['\$1'] as String,
        year: (json['value3']['current_year'] as num).toInt(),
      ),
      value4: (
        json['value4']['\$1'] as String,
        active: json['value4']['is_active'] as bool,
        year: (json['value4']['current_year'] as num).toInt(),
      ),
      value5: (
        json['value5']['\$1'] as String,
        active: json['value5']['active'] as bool,
        year: json['value5']['year'] as String,
      ),
      value6: (
        json['value6']['\$1'] as String,
        active: json['value6']['active'] as bool,
        year: (json['value6']['year'] as num).toInt(),
      ),
      value7: json['value7'] == null
          ? null
          : (
              json['value7']['\$1'] as String,
              (json['value7']['\$2'] as num).toInt(),
            ),
      value8: (
        json['value8']['\$1'] as String,
        active: json['value8']['is_active'] as bool,
        year: json['value8']['current_year'] as String,
      ),
    );
  }

  Map<String, dynamic> toJson(Object? Function(T v) toJsonT) {
    final v = this as TupleModel2<T>;
    return <String, dynamic>{
      'value1': <String, dynamic>{
        '\$1': v.value1.$1,
        '\$2': toJsonT(v.value1.$2),
      },
      'value2': <String, dynamic>{
        '\$1': v.value2.$1,
        '\$2': toJsonT(v.value2.$2),
        'flag': v.value2.flag,
        'name': ?v.value2.name,
      },
      'value3': <String, dynamic>{
        '\$1': v.value3.$1,
        'current_year': v.value3.year,
      },
      'value4': <String, dynamic>{
        '\$1': v.value4.$1,
        'is_active': v.value4.active,
        'current_year': v.value4.year,
      },
      'value5': <String, dynamic>{
        '\$1': v.value5.$1,
        'active': v.value5.active,
        'year': v.value5.year,
      },
      'value6': <String, dynamic>{
        '\$1': v.value6.$1,
        'active': v.value6.active,
        'year': v.value6.year,
      },
      'value7': ?(v.value7 == null
          ? null
          : <String, dynamic>{
              '\$1': v.value7!.$1,
              '\$2': v.value7!.$2,
            }),
      'value8': <String, dynamic>{
        '\$1': v.value8.$1,
        'is_active': v.value8.active,
        'current_year': v.value8.year,
      },
    };
  }

  TupleModel2<T> copyWith({
    (String, T)? value1,
    (String, T, {bool flag, String? name})? value2,
    TypeDefTuple? value3,
    TypeDefTupleGen<int>? value4,
    (String, {bool active, String year})? value5,
    (String, {bool active, int year})? value6,
    (String, int)? value7,
    TypeDefTupleGen<String>? value8,
  }) {
    final v = this as TupleModel2<T>;
    return TupleModel2<T>(
      value1: value1 ?? v.value1,
      value2: value2 ?? v.value2,
      value3: value3 ?? v.value3,
      value4: value4 ?? v.value4,
      value5: value5 ?? v.value5,
      value6: value6 ?? v.value6,
      value7: value7 ?? v.value7,
      value8: value8 ?? v.value8,
    );
  }

  @override
  bool operator ==(Object other) {
    final v = this as TupleModel2<T>;
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is TupleModel2<T> &&
            (identical(other.value1, v.value1) || other.value1 == v.value1) &&
            (identical(other.value2, v.value2) || other.value2 == v.value2) &&
            (identical(other.value3, v.value3) || other.value3 == v.value3) &&
            (identical(other.value4, v.value4) || other.value4 == v.value4) &&
            (identical(other.value5, v.value5) || other.value5 == v.value5) &&
            (identical(other.value6, v.value6) || other.value6 == v.value6) &&
            (identical(other.value7, v.value7) || other.value7 == v.value7) &&
            (identical(other.value8, v.value8) || other.value8 == v.value8));
  }

  @override
  int get hashCode {
    final v = this as TupleModel2<T>;
    return Object.hash(
      runtimeType,
      v.value1,
      v.value2,
      v.value3,
      v.value4,
      v.value5,
      v.value6,
      v.value7,
      v.value8,
    );
  }

  @override
  String toString() {
    final v = this as TupleModel2<T>;
    return 'TupleModel2<$T>{value1: ${v.value1}, value2: ${v.value2}, value3: ${v.value3}, value4: ${v.value4}, value5: ${v.value5}, value6: ${v.value6}, value7: ${v.value7}, value8: ${v.value8}}';
  }
}
