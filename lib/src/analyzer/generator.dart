import 'dart:io';

import 'package:macro_kit/macro.dart';
import 'package:macro_kit/src/analyzer/analyzer.dart';
import 'package:macro_kit/src/analyzer/internal_models.dart';
import 'package:macro_kit/src/analyzer/models.dart';

extension Generator on Analyzer {
  /// group parsed macro code and run user code generation
  Future<void> executeMacro({
    required String path,
    required Map<String, AnalyzeResult> result,
    required Map<String, MacroClassDeclaration> sharedClasses,
  }) async {
    // step:1 group macro by name
    Map<String, RunMacroMsg> runConfigs = {};
    for (final entry in result.entries) {
      final macroName = entry.key;
      final analyzeRes = entry.value;

      final res = runConfigs[macroName];
      if (res == null) {
        runConfigs[macroName] = RunMacroMsg(
          id: newId(),
          macroName: macroName,
          sharedClasses: sharedClasses,
          classes: analyzeRes.classes,
        );
      } else {
        res.classes!.addAll(analyzeRes.classes);
      }
    }

    // step:2 run the macro generator
    final (baseName, generatedFilePath) = buildGeneratedFileInfo(path);

    final generated = StringBuffer();
    final header =
        '''
// GENERATED BY Macro: DO NOT MODIFY BY HAND
    
part of '$baseName';

''';

    generated.write(header);
    bool fileGenerated = false;

    for (final runConfigEntry in runConfigs.entries) {
      final macroName = runConfigEntry.key;
      final msg = runConfigEntry.value;
      var clientChannelId = getClientChannelFor(macroName);

      if (clientChannelId == null) {
        requestClientToConnect();
        await Future.delayed(const Duration(seconds: 2));

        clientChannelId = getClientChannelFor(macroName);
        if (clientChannelId == null) {
          logger.error('No Macro generator found for: $macroName');
          onClientError(-1, 'No Macro generator found for: $macroName');
          return;
        }
      }

      try {
        final runRes = await runMacroGenerator(clientChannelId, msg);
        if (runRes.error?.isNotEmpty == true) {
          onClientError(clientChannelId, runRes.error!);
          return;
        }

        fileGenerated = true;
        generated
          ..write(runRes.result)
          ..write('\n');
      } catch (e, s) {
        onClientError(clientChannelId, e.toString(), e, s);
        return;
      }
    }

    if (!fileGenerated) {
      removeFile(generatedFilePath);
      return;
    }

    // TODO: make all generated file in one location if possible?
    // step:3 generate the part file
    final partFile = fileCaches.putIfAbsent(generatedFilePath, () => File(generatedFilePath));
    final codeRes = generated.toString();

    try {
      partFile.writeAsStringSync(formatter.format(codeRes, uri: path));
    } catch (e) {
      logger.warn('Formatting generated code fails', e);
      partFile.writeAsStringSync(codeRes);
    } finally {
      _cleanupCachedFile();
    }
  }

  void _cleanupCachedFile() {
    if (fileCaches.length > 50) {
      final values = fileCaches.entries.toList().reversed.take(25);
      fileCaches.clear();
      fileCaches.addEntries(values);
    }
  }
}
