import 'dart:io';

import 'package:macro_kit/macro_kit.dart';
import 'package:macro_kit/src/analyzer/base.dart';
import 'package:macro_kit/src/analyzer/internal_models.dart';
import 'package:macro_kit/src/analyzer/types_ext.dart';
import 'package:macro_kit/src/common/models.dart';

mixin Generator on BaseAnalyzer {
  /// group parsed macro code and run user code generation
  Future<void> executeMacro({
    required String path,
    required Map<String, String> imports,
    required Map<int, String> libraryPaths,
    required Map<String, AnalyzeResult> result,
    required Map<String, MacroClassDeclaration> sharedClasses,
  }) async {
    // step:1 group macro by name
    Map<String, RunMacroMsg> runConfigs = {};
    for (final entry in result.entries) {
      final macroName = entry.key;
      final analyzeRes = entry.value;

      final res = runConfigs[macroName];
      if (res == null) {
        runConfigs[macroName] = RunMacroMsg(
          id: newId(),
          macroName: macroName,
          path: path,
          imports: imports,
          libraryPaths: libraryPaths,
          sharedClasses: sharedClasses,
          classes: analyzeRes.classes,
        );
      } else {
        res.classes!.addAll(analyzeRes.classes);
      }
    }

    // step:2 configure the generated file path
    final (:genFilePath, :relativePartFilePath) = buildGeneratedFileInfo(path);
    // step:3 run the macro generator

    final generated = StringBuffer();
    final header =
        '''
// GENERATED BY Macro: DO NOT MODIFY BY HAND

part of '$relativePartFilePath';

''';

    generated.write(header);
    bool fileGenerated = false;

    for (final runConfigEntry in runConfigs.entries) {
      final macroName = runConfigEntry.key;
      final msg = runConfigEntry.value;

      // ignore message with empty class to not generate empty file
      if (msg.classes == null || msg.classes!.isEmpty) {
        continue;
      }

      var clientChannelId = getClientChannelIdByMacro(macroName, path);

      if (clientChannelId == null) {
        requestClientToConnect();
        await Future.delayed(const Duration(seconds: 3));

        clientChannelId = getClientChannelIdByMacro(macroName, path);
        if (clientChannelId == null) {
          logger.error('No Macro generator found for: $macroName');
          onClientError(-1, 'No Macro generator found for: $macroName');
          return;
        }
      }

      try {
        final runRes = await runMacroGenerator(clientChannelId, msg);
        if (runRes.error?.isNotEmpty == true) {
          onClientError(clientChannelId, runRes.error!);
          return;
        }

        fileGenerated = true;
        generated
          ..write(runRes.result)
          ..write('\n');
      } catch (e, s) {
        onClientError(clientChannelId, e.toString(), e, s);
        return;
      }
    }

    if (!fileGenerated) {
      removeFile(genFilePath);
      return;
    }

    // step:3 generate the part file
    final partFile = fileCaches.putIfAbsent(path, () => File(genFilePath));
    final codeRes = _formatCode(generated, genFilePath);

    final error = partFile.writeDataSyncOrErr(codeRes, createFile: true, recursive: true);
    if (error != null) {
      logger.error('Failed to write generated code into: $genFilePath', error);
    }

    _cleanupCachedFile();
  }

  Future<void> executeAssetMacro({
    required String path,
    required AssetChangeType changeType,
    required List<AnalyzingAsset> macros,
  }) async {
    // step:1 map each config to a macro asset declaration, ready to be run
    final runConfigs = macros
        .map(
          (assetMacro) => RunMacroMsg(
            id: newId(),
            macroName: assetMacro.macro.macroName,
            path: path,
            imports: imports,
            libraryPaths: libraryPathById,
            assetDeclaration: MacroAssetDeclaration(path: path, type: changeType),
            assetConfig: assetMacro.macro.config,
            assetBasePath: assetMacro.relativeBasePath,
            assetAbsoluteBasePath: assetMacro.absoluteBasePath,
            assetAbsoluteOutputPath: assetMacro.absoluteOutputPath,
          ),
        )
        .toList();

    // step:2 run the macro generator
    // final generatedFiles = <String>[];
    for (final msg in runConfigs) {
      var clientChannelId = getClientChannelIdByMacro(msg.macroName, path);

      if (clientChannelId == null) {
        requestClientToConnect();
        await Future.delayed(const Duration(seconds: 3));

        clientChannelId = getClientChannelIdByMacro(msg.macroName, path);
        if (clientChannelId == null) {
          logger.error('No Macro generator found for: ${msg.macroName}');
          onClientError(-1, 'No Macro generator found for: ${msg.macroName}');
          return;
        }
      }

      try {
        final runRes = await runMacroGenerator(clientChannelId, msg);
        if (runRes.error?.isNotEmpty == true) {
          onClientError(clientChannelId, runRes.error!);
          return;
        }

        // generatedFiles.addAll(runRes.generatedFiles ?? const []);
      } catch (e, s) {
        onClientError(clientChannelId, e.toString(), e, s);
        return;
      }
    }

    // TODO: process generated file?
    _cleanupCachedFile();
  }

  @pragma('vm:prefer-inline')
  String _formatCode(StringBuffer buffer, String path) {
    final code = buffer.toString();

    try {
      return formatter.format(code, uri: path);
    } catch (e) {
      logger.warn('Formatting generated code fails', e);
      return code;
    }
  }

  void _cleanupCachedFile() {
    if (fileCaches.length > 50) {
      final values = fileCaches.entries.toList().reversed.take(25);
      fileCaches.clear();
      fileCaches.addEntries(values);
    }
  }
}
