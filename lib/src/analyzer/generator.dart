import 'dart:io';

import 'package:macro_kit/macro_kit.dart';
import 'package:macro_kit/src/analyzer/base.dart';
import 'package:macro_kit/src/analyzer/internal_models.dart';
import 'package:macro_kit/src/analyzer/types_ext.dart';
import 'package:macro_kit/src/common/models.dart';

mixin Generator on BaseAnalyzer {
  /// group parsed macro code and run user code generation
  Future<void> executeMacro({
    required String path,
    required Map<String, String> imports,
    required Map<int, String> libraryPaths,
    required Map<String, AnalyzeResult> result,
    required Map<String, MacroClassDeclaration> sharedClasses,
  }) async {
    // step:1 group macro by name
    Map<String, RunMacroMsg> runConfigs = {};
    for (final entry in result.entries) {
      final macroName = entry.key;
      final analyzeRes = entry.value;

      final res = runConfigs[macroName];
      if (res == null) {
        runConfigs[macroName] = RunMacroMsg(
          id: newId(),
          macroName: macroName,
          path: path,
          imports: imports,
          libraryPaths: libraryPaths,
          sharedClasses: sharedClasses,
          classes: analyzeRes.classes,
          topLevelFunctions: analyzeRes.topLevelFunctions ?? [],
          records: analyzeRes.records ?? [],
        );
      } else {
        res.classes!.addAll(analyzeRes.classes);
        res.records!.addAll(analyzeRes.records ?? const []);
        res.topLevelFunctions!.addAll(analyzeRes.topLevelFunctions ?? const []);
      }
    }

    // step:2 configure the generated file path
    final (:genFilePath, partFromSource: partFromSource, :partFromGenerated) = server.buildGeneratedFileInfo(path);

    // step:3 run the macro generator
    final generated = StringBuffer("part of '$partFromGenerated';");
    bool fileGenerated = false;

    for (final runConfigEntry in runConfigs.entries) {
      final macroName = runConfigEntry.key;
      final msg = runConfigEntry.value;

      // ignore message with empty applied to not generate empty file
      if (msg.classes?.isNotEmpty != true &&
          msg.records?.isNotEmpty != true &&
          msg.topLevelFunctions?.isNotEmpty != true) {
        continue;
      }

      var clientChannelId = server.getClientChannelIdByMacro(macroName, path);

      if (clientChannelId == null) {
        server.requestClientToConnect();
        await Future.delayed(const Duration(seconds: 3));

        clientChannelId = server.getClientChannelIdByMacro(macroName, path);
        if (clientChannelId == null) {
          logger.error('No Macro generator found for: $macroName');
          server.onClientError(-1, 'No Macro generator found for: $macroName');
          return;
        }
      }

      final (runRes, err, trace) = await server.runMacroGenerator(clientChannelId, msg).awaitValueTraced();
      if (err != null) {
        server.onClientError(clientChannelId, err.toString(), err, trace);
        return;
      } else if (runRes!.error?.isNotEmpty == true) {
        server.onClientError(clientChannelId, runRes.error!);
        return;
      }

      fileGenerated = true;
      generated
        ..write(runRes.result)
        ..write('\n');
    }

    if (!fileGenerated) {
      removeFile(genFilePath);
      return;
    }

    // step:3 generate the part file
    final partFile = File(genFilePath);
    final codeRes = _formatCode(generated, genFilePath);

    const topHeader = '''
// coverage:ignore-file
// GENERATED BY Macro: DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, unused_local_variable, unnecessary_overrides, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark
// dart format off

''';
    final error = partFile.writeDataSyncOrErr(topHeader + codeRes, createFile: true, recursive: true);
    if (error != null) {
      logger.error('Failed to write generated code into: $genFilePath', error);
    }
  }

  Future<void> executeAssetMacro({
    required String path,
    required AssetChangeType changeType,
    required List<AnalyzingAsset> macros,
  }) async {
    // step:1 map each config to a macro asset declaration, ready to be run
    final runConfigs = macros
        .map(
          (assetMacro) => RunMacroMsg(
            id: newId(),
            macroName: assetMacro.macro.macroName,
            path: path,
            imports: imports,
            libraryPaths: libraryPathById,
            assetDeclaration: MacroAssetDeclaration(path: path, type: changeType),
            assetConfig: assetMacro.macro.config,
            assetBasePath: assetMacro.relativeBasePath,
            assetAbsoluteBasePath: assetMacro.absoluteBasePath,
            assetAbsoluteOutputPath: assetMacro.absoluteOutputPath,
          ),
        )
        .toList();

    // step:2 run the macro generator
    // final generatedFiles = <String>[];
    for (final msg in runConfigs) {
      var clientChannelId = server.getClientChannelIdByMacro(msg.macroName, path);

      if (clientChannelId == null) {
        server.requestClientToConnect();
        await Future.delayed(const Duration(seconds: 3));

        clientChannelId = server.getClientChannelIdByMacro(msg.macroName, path);
        if (clientChannelId == null) {
          logger.error('No Macro generator found for: ${msg.macroName}');
          server.onClientError(-1, 'No Macro generator found for: ${msg.macroName}');
          return;
        }
      }

      final (runRes, err, trace) = await server.runMacroGenerator(clientChannelId, msg).awaitValueTraced();
      if (err != null) {
        server.onClientError(clientChannelId, err.toString(), err, trace);
        return;
      } else if (runRes?.error?.isNotEmpty == true) {
        server.onClientError(clientChannelId, runRes!.error!);
        return;
      }

      // generatedFiles.addAll(runRes.generatedFiles ?? const []);
    }

    // TODO: process generated file?
  }

  @pragma('vm:prefer-inline')
  String _formatCode(StringBuffer buffer, String path) {
    final code = buffer.toString();

    try {
      return formatter.format(code, uri: path);
    } catch (e) {
      logger.warn('Formatting generated code failed', e);
      return code;
    }
  }
}
