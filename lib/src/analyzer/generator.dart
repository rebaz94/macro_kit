import 'dart:io';

import 'package:macro_kit/macro.dart';
import 'package:macro_kit/src/analyzer/base.dart';
import 'package:macro_kit/src/analyzer/internal_models.dart';
import 'package:macro_kit/src/analyzer/models.dart';
import 'package:macro_kit/src/analyzer/types_ext.dart';

mixin Generator on BaseAnalyzer {
  /// group parsed macro code and run user code generation
  Future<void> executeMacro({
    required String path,
    required Map<String, AnalyzeResult> result,
    required Map<String, MacroClassDeclaration> sharedClasses,
  }) async {
    // step:1 group macro by name
    Map<String, RunMacroMsg> runConfigs = {};
    for (final entry in result.entries) {
      final macroName = entry.key;
      final analyzeRes = entry.value;

      final res = runConfigs[macroName];
      if (res == null) {
        runConfigs[macroName] = RunMacroMsg(
          id: newId(),
          macroName: macroName,
          sharedClasses: sharedClasses,
          classes: analyzeRes.classes,
        );
      } else {
        res.classes!.addAll(analyzeRes.classes);
      }
    }

    // step:2 configure the generated file path
    final (:genFilePath, :relativePartFilePath) = buildGeneratedFileInfo(path);
    // step:3 run the macro generator

    final generated = StringBuffer();
    final header =
        '''
// GENERATED BY Macro: DO NOT MODIFY BY HAND

part of '$relativePartFilePath';

''';

    generated.write(header);
    bool fileGenerated = false;

    for (final runConfigEntry in runConfigs.entries) {
      final macroName = runConfigEntry.key;
      final msg = runConfigEntry.value;
      var clientChannelId = getClientChannelFor(macroName);

      if (clientChannelId == null) {
        requestClientToConnect();
        await Future.delayed(const Duration(seconds: 2));

        clientChannelId = getClientChannelFor(macroName);
        if (clientChannelId == null) {
          logger.error('No Macro generator found for: $macroName');
          onClientError(-1, 'No Macro generator found for: $macroName');
          return;
        }
      }

      try {
        final runRes = await runMacroGenerator(clientChannelId, msg);
        if (runRes.error?.isNotEmpty == true) {
          onClientError(clientChannelId, runRes.error!);
          return;
        }

        fileGenerated = true;
        generated
          ..write(runRes.result)
          ..write('\n');
      } catch (e, s) {
        onClientError(clientChannelId, e.toString(), e, s);
        return;
      }
    }

    if (!fileGenerated) {
      removeFile(genFilePath);
      return;
    }

    // TODO: make all generated file in one location if possible?
    // step:3 generate the part file
    final partFile = fileCaches.putIfAbsent(path, () => File(genFilePath));
    final codeRes = _formatCode(generated, genFilePath);

    final error = partFile.writeDataSyncOrErr(codeRes, createFile: true, recursive: true);
    if (error != null) {
      logger.error('Failed to write generated code into: $genFilePath', error);
    }

    _cleanupCachedFile();
  }

  @pragma('vm:prefer-inline')
  String _formatCode(StringBuffer buffer, String path) {
    final code = buffer.toString();

    try {
      return formatter.format(code, uri: path);
    } catch (e) {
      logger.warn('Formatting generated code fails', e);
      return code;
    }
  }

  void _cleanupCachedFile() {
    if (fileCaches.length > 50) {
      final values = fileCaches.entries.toList().reversed.take(25);
      fileCaches.clear();
      fileCaches.addEntries(values);
    }
  }
}
