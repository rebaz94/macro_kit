extension MacroExt on Enum {
  /// Returns the key associated with value [source] from [enumValues], if one
  /// exists.
  ///
  /// If [unknownValue] is not `null` and [source] is not a value in [enumValues],
  /// [unknownValue] is returned. Otherwise, an [ArgumentError] is thrown.
  ///
  /// If [source] is `null`, `null` is returned.
  ///
  /// Exposed only for code generated by `package:json_serializable`.
  /// Not meant to be used directly by user code.
  static K? decodeNullableEnum<K extends Enum, V>(
    List<K> enumValues, //
    Object? source, {
    Enum? unknownValue,
  }) {
    if (source == null) {
      return null;
    }

    for (var entry in enumValues) {
      if (entry.name == source) {
        return entry;
      }
    }

    if (unknownValue == null) {
      return null;
    }

    if (unknownValue is! K) {
      throw ArgumentError.value(
        unknownValue,
        'unknownValue',
        'Must by of type `$K` or `JsonKey.nullForUndefinedEnumValue`.',
      );
    }

    return unknownValue;
  }

  /// Returns the key associated with value [source] from [enumValues], if one
  /// exists.
  ///
  /// If [unknownValue] is not `null` and [source] is not a value in [enumValues],
  /// [unknownValue] is returned. Otherwise, an [ArgumentError] is thrown.
  ///
  /// If [source] is `null`, an [ArgumentError] is thrown.
  ///
  /// Exposed only for code generated by `package:json_serializable`.
  /// Not meant to be used directly by user code.
  static K decodeEnum<K extends Enum, V>(List<K> enumValues, Object? source, {K? unknownValue}) {
    if (source == null) {
      throw ArgumentError(
        'A value must be provided. Supported values: '
        '${enumValues.join(', ')}',
      );
    }

    for (var entry in enumValues) {
      if (entry.name == source) {
        return entry;
      }
    }

    if (unknownValue == null) {
      throw ArgumentError(
        '`$source` is not one of the supported values: '
        '${enumValues.join(', ')}',
      );
    }

    return unknownValue;
  }

  static DateTime? decodeNullableDateTime(Object? value) {
    const errMsg = 'Invalid DateTime value';
    if (value == null) return null;

    if (value is String) {
      final dateTime = DateTime.tryParse(value);
      if (dateTime != null) return dateTime;

      final unixTime = num.tryParse(value);
      if (unixTime == null) throw errMsg;

      return DateTime.fromMicrosecondsSinceEpoch(unixTime.toInt() * 1000);
    } else if (value is num) {
      return DateTime.fromMicrosecondsSinceEpoch(value.toInt() * 1000);
    }

    throw errMsg;
  }

  static DateTime decodeDateTime(Object? value) {
    const errMsg = 'Invalid DateTime value';
    if (value == null) throw errMsg;

    if (value is String) {
      final dateTime = DateTime.tryParse(value);
      if (dateTime != null) return dateTime;

      final unixTime = num.tryParse(value);
      if (unixTime == null) throw errMsg;

      return DateTime.fromMicrosecondsSinceEpoch(unixTime.toInt() * 1000);
    } else if (value is num) {
      return DateTime.fromMicrosecondsSinceEpoch(value.toInt() * 1000);
    }

    throw errMsg;
  }

  static T? decodeNullableGeneric<T>(Object? input, T? Function(Object? value) fromJson) {
    return input == null ? null : fromJson(input);
  }

  static Object? encodeNullableGeneric<T>(T? input, Object? Function(T value) toJson) {
    return input == null ? null : toJson(input);
  }
}
