extension MacroExt on Enum {
  /// Returns the key associated with value [source] from [enumValues], if one
  /// exists.
  ///
  /// If [unknownValue] is not `null` and [source] is not a value in [enumValues],
  /// [unknownValue] is returned. Otherwise, an [ArgumentError] is thrown.
  ///
  /// If [source] is `null`, `null` is returned.
  ///
  /// Exposed only for code generated by `package:json_serializable`.
  /// Not meant to be used directly by user code.
  static K? decodeNullableEnum<K extends Enum, V>(
    List<K> enumValues, //
    Object? source, {
    Enum? unknownValue,
  }) {
    if (source == null) {
      return null;
    }

    for (var entry in enumValues) {
      if (entry.name == source) {
        return entry;
      }
    }

    if (unknownValue == null) {
      return null;
    }

    if (unknownValue is! K) {
      throw ArgumentError.value(
        unknownValue,
        'unknownValue',
        'Must by of type `$K` or `JsonKey.nullForUndefinedEnumValue`.',
      );
    }

    return unknownValue;
  }

  /// Returns the key associated with value [source] from [enumValues], if one
  /// exists.
  ///
  /// If [unknownValue] is not `null` and [source] is not a value in [enumValues],
  /// [unknownValue] is returned. Otherwise, an [ArgumentError] is thrown.
  ///
  /// If [source] is `null`, an [ArgumentError] is thrown.
  ///
  /// Exposed only for code generated by `package:json_serializable`.
  /// Not meant to be used directly by user code.
  static K decodeEnum<K extends Enum, V>(List<K> enumValues, Object? source, {K? unknownValue}) {
    if (source == null) {
      throw ArgumentError(
        'A value must be provided. Supported values: '
        '${enumValues.join(', ')}',
      );
    }

    for (var entry in enumValues) {
      if (entry.name == source) {
        return entry;
      }
    }

    if (unknownValue == null) {
      throw ArgumentError(
        '`$source` is not one of the supported values: '
        '${enumValues.join(', ')}',
      );
    }

    return unknownValue;
  }

  static DateTime? decodeNullableDateTime(Object? value) {
    const errMsg = 'Invalid DateTime value';
    if (value == null) return null;

    if (value is String) {
      final dateTime = DateTime.tryParse(value);
      if (dateTime != null) return dateTime;

      final unixTime = num.tryParse(value);
      if (unixTime == null) throw errMsg;

      return DateTime.fromMicrosecondsSinceEpoch(unixTime.toInt() * 1000);
    } else if (value is num) {
      return DateTime.fromMicrosecondsSinceEpoch(value.toInt() * 1000);
    }

    throw errMsg;
  }

  static DateTime decodeDateTime(Object? value) {
    const errMsg = 'Invalid DateTime value';
    if (value == null) throw errMsg;

    if (value is String) {
      final dateTime = DateTime.tryParse(value);
      if (dateTime != null) return dateTime;

      final unixTime = num.tryParse(value);
      if (unixTime == null) throw errMsg;

      return DateTime.fromMicrosecondsSinceEpoch(unixTime.toInt() * 1000);
    } else if (value is num) {
      return DateTime.fromMicrosecondsSinceEpoch(value.toInt() * 1000);
    }

    throw errMsg;
  }

  static T? decodeNullableGeneric<T>(Object? input, T? Function(Object? value) fromJson) {
    return input == null ? null : fromJson(input);
  }

  static Object? encodeNullableGeneric<T>(T? input, Object? Function(T value) toJson) {
    return input == null ? null : toJson(input);
  }
}

/// A type-safe wrapper for representing optional values in copyWith methods.
///
/// [Option<T>] distinguishes between three states:
/// - **undefined**: The field was not provided
/// - **value**: The field was explicitly set to a value (including null)
/// - **nil**: Shorthand for explicitly setting to null
///
/// This enables proper null assignment in copyWith methods for nullable fields.
///
/// Example:
/// ```dart
/// user.copyWith(
///   email: .value(null),      // Explicitly set to null
///   age: .nil(),              // Explicitly set to null
///   address: .value('US'),    // Explicitly set nullable field value
/// );
/// ```
extension type const Option<T>._(Object? iValue) {
  /// Creates an Option with an explicit value (including null).
  ///
  /// Use this to set a field to a specific value in copyWith.
  const Option.value(T? value) : iValue = value;

  /// Creates an undefined Option.
  ///
  /// Represents "not provided" - the field will keep its existing value.
  /// This is the default state when a parameter is omitted in copyWith.
  const Option.undefined() : iValue = _undefinedSentinel;

  /// Creates an Option explicitly set to null.
  ///
  /// Shorthand for `Option.value(null)`. Use this to explicitly
  /// set a nullable field to null in copyWith.
  const Option.nil() : iValue = null;

  /// Returns the wrapped value if it's of type [T], otherwise null.
  ///
  /// Returns null for both undefined options and null values.
  T? get valueOrNull {
    if (iValue case T? v) {
      return v;
    }

    return null;
  }

  /// Returns true if this Option is undefined (field not provided).
  @pragma('vm:prefer-inline')
  @pragma('dart2js:tryInline')
  bool get isUndefined => identical(iValue, _undefinedSentinel);

  /// Casts the internal value to type [V].
  ///
  /// Used internally by generated code to retrieve the actual value.
  /// Ensure value is set using [isUndefined] before using this method
  @pragma('vm:prefer-inline')
  @pragma('dart2js:tryInline')
  V casted<V>() => iValue as V;

  /// Sentinel value representing an undefined/not-provided state.
  static const _undefinedSentinel = Object();
}
